
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>TWAS, cTWAS and MR &#8212; FunGen-xQTL Consortium</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'code/pecotmr_integration/twas_ctwas';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Multi-trait colocalization using ColocBoost" href="../mnm_analysis/mnm_methods/colocboost.html" />
    <link rel="prev" title="xQTL-GWAS pairwise enrichment and colocalization" href="SuSiE_enloc.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../README.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/xqtl_wf.png" class="logo__image only-light" alt="FunGen-xQTL Consortium - Home"/>
    <script>document.write(`<img src="../../_static/xqtl_wf.png" class="logo__image only-dark" alt="FunGen-xQTL Consortium - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../README.html">
                    FunGen-xQTL Computational Protocol
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../xqtl_protocol_demo.html">Illustration of xQTL protocol</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Command Generator</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../commands_generator/bulk_expression_commands.html">RNA-seq calling and QC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../commands_generator/eQTL_analysis_commands.html">Univariate xQTL Discovery</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Reference data</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../reference_data/reference_data.html">Reference Data</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference_data/reference_data_preparation.html">Reference Data Standardization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_data/generalized_TADB.html">Generation of Topologically Associated Domains and their Boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_data/ld_prune_reference.html">Independent list of variants using LD clumping</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_data/ld_reference_generation.html">Generating LD Reference Panel</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Molecular Phenotypes</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../molecular_phenotypes/bulk_expression.html">RNA-seq expression</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../molecular_phenotypes/calling/RNA_calling.html">Quantifying expression from RNA-seq data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../molecular_phenotypes/QC/bulk_expression_QC.html">Sample level RNA-seq quality control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../molecular_phenotypes/QC/bulk_expression_normalization.html">Bulk RNA-seq counts normalization</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../molecular_phenotypes/methylation.html">Methylation</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../molecular_phenotypes/calling/methylation_calling.html">Quantification of methylation data</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../molecular_phenotypes/splicing.html">Alternative splicing from RNA-seq data</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../molecular_phenotypes/calling/splicing_calling.html">Quantifying alternative splicing from RNA-seq data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../molecular_phenotypes/QC/splicing_normalization.html">Normalization and phenotype table generation for splicingQTL analysis</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Data Pre-processing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../data_preprocessing/genotype_preprocessing.html">Genotype data preprocessing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../data_preprocessing/genotype/VCF_QC.html">Genotype VCF File Quality Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_preprocessing/genotype/GWAS_QC.html">Genotype PLINK File Quality Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_preprocessing/genotype/PCA.html">Principal Component Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_preprocessing/genotype/GRM.html">Genomic Relationship Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_preprocessing/genotype/genotype_formatting.html">Genotype Data Formatting</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../data_preprocessing/phenotype_preprocessing.html">Phenotype data preprocessing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../data_preprocessing/phenotype/gene_annotation.html">Gene Coordinate Annotation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_preprocessing/phenotype/phenotype_imputation.html">Phenotype data imputation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_preprocessing/phenotype/phenotype_formatting.html">Phenotype Data Formatting</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../data_preprocessing/covariate_preprocessing.html">Covariate Data Preprocessing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../data_preprocessing/covariate/covariate_formatting.html">Covariate Data Formatting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_preprocessing/covariate/covariate_hidden_factor.html">Hidden Factor Analysis</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">QTL Association Testing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../association_scan/qtl_association_testing.html">QTL Association Analysis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../association_scan/TensorQTL/TensorQTL.html">QTL Association Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../association_scan/quantile_models/qr_and_twas.html">Quantile regression for QTL association testing</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../association_scan/qtl_association_postprocessing.html">Hierarchical Multiple Testing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Multivariate Mixture Model</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../multivariate_genome/multivariate_mixture_vignette.html">Mixture Multivariate Distribution Estimate</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../multivariate_genome/MASH/mixture_prior.html">A multivariate EBNM approach for mixture multivariate distribution estimate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../multivariate_genome/MASH/mash_fit.html">MASH analysis pipeline with data-driven prior matrices</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Multiomics Regression Models</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../mnm_analysis/mnm_miniprotocol.html">Integrative Analysis with High-Dimensional Regression</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../mnm_analysis/univariate_fine_mapping_twas_vignette.html">Univariate Fine-Mapping and TWAS with SuSiE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mnm_analysis/multivariate_multigene_fine_mapping_vignette.html">Multivariate Fine-Mapping for multiple genes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mnm_analysis/univariate_fine_mapping_fsusie_vignette.html">Univariate Fine-Mapping of Functional (Epigenomic) Data with fSuSiE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mnm_analysis/multivariate_fine_mapping_vignette.html">Multivariate Fine-Mapping with mvSuSiE and mr.mash</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mnm_analysis/summary_stats_finemapping_vignette.html">Regression with Summary Statistics (RSS) Fine-Mapping and TWAS with SuSiE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mnm_analysis/mnm_methods/mnm_regression.html">Advanced regression models for association analysis with individual level data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mnm_analysis/mnm_methods/rss_analysis.html">High-dimensional regression with summary statistics</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../mnm_analysis/mnm_postprocessing.html">Integrative Analysis Output Processing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">GWAS Integration</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="SuSiE_enloc.html">xQTL-GWAS pairwise enrichment and colocalization</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">TWAS, cTWAS and MR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mnm_analysis/mnm_methods/colocboost.html">Multi-trait colocalization using ColocBoost</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Enrichment and Validation</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../enrichment/eoo_enrichment.html">Chromosome-Specific Enrichment Analysis of Annotations Using Block Jackknife</a></li>
<li class="toctree-l1"><a class="reference internal" href="../enrichment/gsea.html">Pathway Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../enrichment/gregor.html">GREGOR enrichment analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../enrichment/sldsc_enrichment.html">Stratified LD Score Regression</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">xQTL Modifier Score</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../xqtl_modifier_score/ems_training.html">EMS Training</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xqtl_modifier_score/ems_prediction.html">EMS Prediction for xQTL Modifier Scores</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/statfungen/xqtl-protocol/edit/gh-pages/code/pecotmr_integration/twas_ctwas.ipynb" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/statfungen/xqtl-protocol/issues/new?title=Issue%20on%20page%20%2Fcode/pecotmr_integration/twas_ctwas.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/code/pecotmr_integration/twas_ctwas.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>TWAS, cTWAS and MR</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-1-twas">Step 1: TWAS</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-2-variant-selection-for-imputable-genes-via-the-best-prediction-methods">Step 2: Variant Selection for Imputable Genes via the Best Prediction Methods</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-3-ctwas-analysis">Step 3: cTWAS analysis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-4-mr-for-candidate-genes">Step 4: MR for candidate genes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-5-quantile-twas-analysis">Step 5: Quantile TWAS analysis</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#input">Input</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwas-data-input-interface-similar-to-susie-rss">GWAS Data Input Interface (Similar to <code class="docutils literal notranslate"><span class="pre">susie_rss</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#output-of-fine-mapping-twas-pipeline">Output of Fine-Mapping &amp; TWAS Pipeline</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#twas-region-information">TWAS region information</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#output">Output</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iii-run-twas">iii. Run TWAS</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iv-run-ctwas">iv. Run cTWAS</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="twas-ctwas-and-mr">
<h1>TWAS, cTWAS and MR<a class="headerlink" href="#twas-ctwas-and-mr" title="Link to this heading">#</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">#</a></h2>
<p>This module provides software implementations for transcriptome-wide association analysis (TWAS), Quantile TWAS and performs variant selection for providing sparse signals for cTWAS (causal TWAS) analysis as described in Qian et al (2024+) the multi-group cTWAS method. It will additionally perform Mendelian Randomization using fine-mapping instrumental variables (IV) as described in Zhang et al 2020 for “causal” effects estimation and model validation, with the unit of analysis being a single gene-trait pair.</p>
<p>This procedure is a continuation of the SuSiE-TWAS workflow — it assumes that xQTL fine-mapping has been performed and moleuclar traits prediction weights pre-computed (to be used for TWAS). Cross validation for TWAS weights is optional but highly recommended.</p>
<p>Quantile TWAS extends traditional TWAS by testing genetic effects at different quantiles of the trait distribution, which provides insights into genetic associations that vary across the distribution rather than just at the mean.</p>
<p>GWAS data required are GWAS summary statistics and LD matrix for the region of interest.</p>
<section id="step-1-twas">
<h3>Step 1: TWAS<a class="headerlink" href="#step-1-twas" title="Link to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Extract GWAS z-score for region of interest and corresponding LD matrix.</p></li>
</ol>
<ul class="simple">
<li><p>Note: When loading GWAS summary statistics, specifying a column_file_path (YAML format) enables the use of load_rss_data(). This function standardizes column names and can flexibly generate missing “z” or “beta” columns using the col_to_flip option. If no column_file_path is provided, the simpler tabix_region() is used instead.</p></li>
<li><p>Note: To handle comment lines in the summary statistics file, use the –comment_string option to specify the comment symbol (e.g., –comment_string “#”, with quotation marks). By default, no comment symbol is assumed.</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>(Optional) perform allele matching QC for the LD matrix with summary stats.</p></li>
<li><p>Process weights: for a number of methods such as LASSO, Elastic Net and mr.ash we have to take the weights as is for QTL variants overlapping with GWAS variants. For SuSiE weights it can be adjusted to exactly match GWAS variants.</p></li>
<li><p>Perofrm TWAS test for multiple sets of weights.</p></li>
<li><p>For each gene, filter TWAS results by keeping the best model selected by CV. Drop the genes that don’t show good evidence of TWAS prediction weights.</p></li>
</ol>
</section>
<section id="step-2-variant-selection-for-imputable-genes-via-the-best-prediction-methods">
<h3>Step 2: Variant Selection for Imputable Genes via the Best Prediction Methods<a class="headerlink" href="#step-2-variant-selection-for-imputable-genes-via-the-best-prediction-methods" title="Link to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Determine if the gene is imputable at each context based on the twas_cv performance by adjusted <span class="math notranslate nohighlight">\(r^2\)</span> (&gt;=0.01) and p-values (&lt;0.05).</p></li>
<li><p>The imputable gene-context pair will go through variant selection step. Maximum 10 variants with top pip selected from either <code class="docutils literal notranslate"><span class="pre">top_loci</span></code> table or SuSiE CS set.</p></li>
<li><p>Harmonize weights against LD reference and udpate SuSiE weight.</p></li>
<li><p>Extract weights by best model for the context then by the variant names were selected from the previous step</p></li>
</ol>
</section>
<section id="step-3-ctwas-analysis">
<h3>Step 3: cTWAS analysis<a class="headerlink" href="#step-3-ctwas-analysis" title="Link to this heading">#</a></h3>
<p><strong>FIXME: add more documentation here</strong></p>
</section>
<section id="step-4-mr-for-candidate-genes">
<h3>Step 4: MR for candidate genes<a class="headerlink" href="#step-4-mr-for-candidate-genes" title="Link to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Limit MR only to those showing some evidence of cTWAS significance AND have strong instrumental variable (fine-mapping PIP or CS).</p></li>
<li><p>Use fine-mapped xQTL with GWAS data to perform MR.</p></li>
<li><p>For multiple IV, aggregate individual IV estimates using a fixed-effect meta-analysis procedure.</p></li>
<li><p>Identify and exclude results with severe violations of the exclusion restriction (ER) assumption.</p></li>
</ol>
</section>
<section id="step-5-quantile-twas-analysis">
<h3>Step 5: Quantile TWAS analysis<a class="headerlink" href="#step-5-quantile-twas-analysis" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Use pre-computed TWAS weights (beta for now) for quantile-specific testing.</p></li>
<li><p>For each quantile level, cluster and integrate by fixed and dynamic region groups, and extract relevant GWAS z-scores and LD matrix for the region of interest.</p></li>
<li><p>Perform quantile region-specific association tests, identifying genetic variants with effects that vary across different quantile regions of the phenotype distribution.</p></li>
</ul>
</section>
</section>
<section id="input">
<h2>Input<a class="headerlink" href="#input" title="Link to this heading">#</a></h2>
<section id="gwas-data-input-interface-similar-to-susie-rss">
<h3>GWAS Data Input Interface (Similar to <code class="docutils literal notranslate"><span class="pre">susie_rss</span></code>)<a class="headerlink" href="#gwas-data-input-interface-similar-to-susie-rss" title="Link to this heading">#</a></h3>
<p>I. <strong>GWAS Summary Statistics Files</strong></p>
<ul class="simple">
<li><p><strong>Input</strong>: Vector of files for one or more GWAS studies.</p></li>
<li><p><strong>Format</strong>:</p>
<ul>
<li><p>Tab-delimited files that is tabix-indexed by the first <code class="docutils literal notranslate"><span class="pre">chrom</span></code>(or <code class="docutils literal notranslate"><span class="pre">#chrom</span></code>) and second <code class="docutils literal notranslate"><span class="pre">pos</span></code> column.</p></li>
<li><p>First 4 columns: <code class="docutils literal notranslate"><span class="pre">chrom</span></code> or <code class="docutils literal notranslate"><span class="pre">#chrom</span></code>, <code class="docutils literal notranslate"><span class="pre">pos</span></code>, <code class="docutils literal notranslate"><span class="pre">A1</span></code>, <code class="docutils literal notranslate"><span class="pre">A2</span></code></p></li>
<li><p>Additional columns can be loaded using column mapping file see below</p></li>
<li><p>If MR, <code class="docutils literal notranslate"><span class="pre">effect_allele_frequency</span></code> and sample size columns(either <code class="docutils literal notranslate"><span class="pre">n_sample</span></code> or <code class="docutils literal notranslate"><span class="pre">n_case</span></code>&amp;<code class="docutils literal notranslate"><span class="pre">n_ccontrol</span></code>) are required.</p></li>
</ul>
</li>
<li><p><strong>Column Mapping files (optional)</strong>:</p>
<ul>
<li><p>Optional YAML file for custom column mapping.</p></li>
<li><p>Required columns: <code class="docutils literal notranslate"><span class="pre">chrom</span></code>, <code class="docutils literal notranslate"><span class="pre">pos</span></code>, <code class="docutils literal notranslate"><span class="pre">A1</span></code>, <code class="docutils literal notranslate"><span class="pre">A2</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> or (<code class="docutils literal notranslate"><span class="pre">betahat</span></code> and <code class="docutils literal notranslate"><span class="pre">sebetahat</span></code>).</p></li>
<li><p>Optional columns: <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">var_y</span></code> (relevant to fine-mapping).</p></li>
</ul>
</li>
</ul>
<p>II. <strong>GWAS Summary Statistics Meta-File</strong>: this is optional and helpful when there are lots of GWAS data to process via the same command</p>
<ul class="simple">
<li><p><strong>Columns</strong>: <code class="docutils literal notranslate"><span class="pre">study_id</span></code>, chromosome number, path to summary statistics file, optional path to column mapping file.</p></li>
<li><p><strong>Note</strong>: Chromosome number <code class="docutils literal notranslate"><span class="pre">0</span></code> indicates a genome-wide file.</p></li>
</ul>
<p>eg: <code class="docutils literal notranslate"><span class="pre">gwas_meta.tsv</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">study_id</span>    <span class="n">chrom</span>    <span class="n">file_path</span>                 <span class="n">column_mapping_file</span>
<span class="n">study1</span>      <span class="mi">1</span>        <span class="n">gwas1</span><span class="o">.</span><span class="n">tsv</span><span class="o">.</span><span class="n">gz</span>         <span class="n">column_mapping</span><span class="o">.</span><span class="n">yml</span>
<span class="n">study1</span>      <span class="mi">2</span>        <span class="n">gwas2</span><span class="o">.</span><span class="n">tsv</span><span class="o">.</span><span class="n">gz</span>         <span class="n">column_mapping</span><span class="o">.</span><span class="n">yml</span>
<span class="n">study2</span>      <span class="mi">0</span>        <span class="n">gwas3</span><span class="o">.</span><span class="n">tsv</span><span class="o">.</span><span class="n">gz</span>         <span class="n">column_mapping</span><span class="o">.</span><span class="n">yml</span>
</pre></div>
</div>
<p>If both summary stats file (I) and meta data file (II) are specified we will take the union of the two.</p>
<p>III. <strong>LD Reference Metadata File</strong></p>
<ul class="simple">
<li><p><strong>Format</strong>: Single TSV file.</p></li>
<li><p><strong>Contents</strong>:</p>
<ul>
<li><p>Columns: <code class="docutils literal notranslate"><span class="pre">#chrom</span></code>, <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, path to the LD matrix, genomic build.</p></li>
<li><p>LD matrix path format: comma-separated, first entry is the LD matrix, second is the bim file.</p></li>
</ul>
</li>
<li><p><strong>Documentation</strong>: Refer to <a class="reference external" href="https://statfungen.github.io/xqtl-protocol/code/reference_data/ld_reference_generation.html">our LD reference preparation document</a> for detailed information.</p></li>
</ul>
</section>
<section id="output-of-fine-mapping-twas-pipeline">
<h3>Output of Fine-Mapping &amp; TWAS Pipeline<a class="headerlink" href="#output-of-fine-mapping-twas-pipeline" title="Link to this heading">#</a></h3>
<p><strong>xQTL Weight Database Metadata File</strong>:</p>
<ul class="simple">
<li><p><strong>Essential columns</strong>: <code class="docutils literal notranslate"><span class="pre">#chr</span></code>, <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, <code class="docutils literal notranslate"><span class="pre">TSS</span></code>, <code class="docutils literal notranslate"><span class="pre">region_id</span></code>, <code class="docutils literal notranslate"><span class="pre">original_data</span></code></p></li>
<li><p><strong>Structure of the weight database</strong>:</p>
<ul>
<li><p>RDS format.</p></li>
<li><p>Organized hierarchically: region → context → weight matrix.</p></li>
<li><p>Each column represents a different method.</p></li>
</ul>
</li>
</ul>
<p>eg: <code class="docutils literal notranslate"><span class="pre">xqtl_meta.tsv</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#chr start end region_id TSS original_data combined_data combined_data_sumstats contexts contexts_top_loci</span>
<span class="n">chr1</span> <span class="mi">0</span> <span class="mi">6480000</span> <span class="n">ENSG00000008128</span> <span class="mi">1724356</span> <span class="s2">&quot;KNIGHT_pQTL.ENSG00000008128.univariate_susie_twas_weights.rds, MiGA_eQTL.ENSG00000008128.univariate_susie_twas_weights.rds, MSBB_eQTL.ENSG00000008128.univariate_susie_twas_weights.rds, ROSMAP_Bennett_Klein_pQTL.ENSG00000008128.univariate_susie_twas_weights.rds, ROSMAP_DeJager_eQTL.ENSG00000008128.univariate_susie_twas_weights.rds, ROSMAP_Kellis_eQTL.ENSG00000008128.univariate_susie_twas_weights.rds, ROSMAP_mega_eQTL.ENSG00000008128.univariate_susie_twas_weights.rds, STARNET_eQTL.ENSG00000008128.univariate_susie_twas_weights.rds&quot;</span> <span class="n">Fungen_xQTL</span><span class="o">.</span><span class="n">ENSG00000008128</span><span class="o">.</span><span class="n">cis_results_db</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">rds</span> <span class="n">Fungen_xQTL</span><span class="o">.</span><span class="n">ENSG00000008128</span><span class="o">.</span><span class="n">cis_results_db</span><span class="o">.</span><span class="n">export_sumstats</span><span class="o">.</span><span class="n">rds</span> <span class="n">Knight_eQTL_brain</span><span class="p">,</span><span class="n">MiGA_GFM_eQTL</span><span class="p">,</span><span class="n">MiGA_GTS_eQTL</span><span class="p">,</span><span class="n">MiGA_SVZ_eQTL</span><span class="p">,</span><span class="n">MiGA_THA_eQTL</span><span class="p">,</span><span class="n">BM_10_MSBB_eQTL</span><span class="p">,</span><span class="n">BM_22_MSBB_eQTL</span><span class="p">,</span><span class="n">BM_36_MSBB_eQTL</span><span class="p">,</span><span class="n">BM_44_MSBB_eQTL</span><span class="p">,</span><span class="n">monocyte_ROSMAP_eQTL</span><span class="p">,</span><span class="n">Mic_DeJager_eQTL</span><span class="p">,</span><span class="n">Ast_DeJager_eQTL</span><span class="p">,</span><span class="n">Oli_DeJager_eQTL</span><span class="p">,</span><span class="n">Exc_DeJager_eQTL</span><span class="p">,</span><span class="n">Inh_DeJager_eQTL</span><span class="p">,</span><span class="n">DLPFC_DeJager_eQTL</span><span class="p">,</span><span class="n">PCC_DeJager_eQTL</span><span class="p">,</span><span class="n">AC_DeJager_eQTL</span><span class="p">,</span><span class="n">Mic_Kellis_eQTL</span><span class="p">,</span><span class="n">Ast_Kellis_eQTL</span><span class="p">,</span><span class="n">Oli_Kellis_eQTL</span><span class="p">,</span><span class="n">OPC_Kellis_eQTL</span><span class="p">,</span><span class="n">Exc_Kellis_eQTL</span><span class="p">,</span><span class="n">Inh_Kellis_eQTL</span><span class="p">,</span><span class="n">Ast_mega_eQTL</span><span class="p">,</span><span class="n">Exc_mega_eQTL</span><span class="p">,</span><span class="n">Inh_mega_eQTL</span><span class="p">,</span><span class="n">Oli_mega_eQTL</span><span class="p">,</span><span class="n">STARNET_eQTL_Mac</span> <span class="n">Knight_eQTL_brain</span><span class="p">,</span><span class="n">MiGA_GFM_eQTL</span><span class="p">,</span><span class="n">MiGA_GTS_eQTL</span><span class="p">,</span><span class="n">MiGA_SVZ_eQTL</span><span class="p">,</span><span class="n">MiGA_THA_eQTL</span><span class="p">,</span><span class="n">BM_10_MSBB_eQTL</span><span class="p">,</span><span class="n">BM_22_MSBB_eQTL</span><span class="p">,</span><span class="n">BM_36_MSBB_eQTL</span><span class="p">,</span><span class="n">BM_44_MSBB_eQTL</span><span class="p">,</span><span class="n">monocyte_ROSMAP_eQTL</span><span class="p">,</span><span class="n">Mic_DeJager_eQTL</span><span class="p">,</span><span class="n">Ast_DeJager_eQTL</span><span class="p">,</span><span class="n">Oli_DeJager_eQTL</span><span class="p">,</span><span class="n">Exc_DeJager_eQTL</span><span class="p">,</span><span class="n">Inh_DeJager_eQTL</span><span class="p">,</span><span class="n">DLPFC_DeJager_eQTL</span><span class="p">,</span><span class="n">PCC_DeJager_eQTL</span><span class="p">,</span><span class="n">AC_DeJager_eQTL</span><span class="p">,</span><span class="n">Mic_Kellis_eQTL</span><span class="p">,</span><span class="n">Ast_Kellis_eQTL</span><span class="p">,</span><span class="n">Oli_Kellis_eQTL</span><span class="p">,</span><span class="n">OPC_Kellis_eQTL</span><span class="p">,</span><span class="n">Exc_Kellis_eQTL</span><span class="p">,</span><span class="n">Inh_Kellis_eQTL</span><span class="p">,</span><span class="n">Ast_mega_eQTL</span><span class="p">,</span><span class="n">Exc_mega_eQTL</span><span class="p">,</span><span class="n">Inh_mega_eQTL</span><span class="p">,</span><span class="n">Oli_mega_eQTL</span><span class="p">,</span><span class="n">STARNET_eQTL_Mac</span>
</pre></div>
</div>
<p>This file is automatically generated as part of the FunGen-xQTL protocol, although only the essential columns are relevant to our application here.</p>
</section>
<section id="twas-region-information">
<h3>TWAS region information<a class="headerlink" href="#twas-region-information" title="Link to this heading">#</a></h3>
<p>This is required for cTWAS analysis, where multiple TWAS and SNP data within each region are combined for joint inference to select the variables, either genes or SNPs, to figure out which variables are likely to be directly associated with the phenotype of interest, rather than being associated through correlations with true causal variables.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">chrom</span>    <span class="n">start</span>    <span class="n">end</span>    <span class="n">block_id</span>  
<span class="mi">1</span>        <span class="mi">1000</span>     <span class="mi">5000</span>   <span class="n">block1</span>    
<span class="mi">2</span>        <span class="mi">2000</span>     <span class="mi">6000</span>   <span class="n">block2</span>
<span class="mi">3</span>        <span class="mi">3000</span>     <span class="mi">7000</span>   <span class="n">block3</span>
</pre></div>
</div>
<p>Timing: ~X min</p>
</section>
</section>
<section id="output">
<h2>Output<a class="headerlink" href="#output" title="Link to this heading">#</a></h2>
<p>I. A table with the following contents</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gwas_study</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">gene</span><span class="p">,</span> <span class="n">TSS</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">is_imputable</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">is_selected_method</span><span class="p">,</span> <span class="n">rsq_adj_cv</span><span class="p">,</span> <span class="n">pval_cv</span><span class="p">,</span> <span class="n">twas_z</span><span class="p">,</span> <span class="n">twas_pval</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TSS</span></code>: Transcription start site</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code>: start and end position of the gene from the <a class="reference external" href="https://github.com/cumc/xqtl-analysis/blob/main/resource/TADB_enhanced_cis.coding.bed">extended TADB window</a> for cis-finemapping</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_imputable</span></code>: status for wether this gene-context pair has  cross-validated performance with r-square &gt; 0.01 and pvalue &lt; 0.05 in at least one method for expression level prediction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rsq_cv</span></code>: cross validation test of r-square for a method.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pval_cv</span></code>: cross-validation test of predictive performance p-value for a method.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_selected_method</span></code>: status of being best performing method (for each gene–context pair), we pick the best model with highest cross validation r-square with cross validation pvalue &lt; 0.05</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block</span></code>: The LD region where the gene’s transcription start site (TSS) is located, based on <a class="reference external" href="https://github.com/cumc/xqtl-data/blob/main/descriptor/reference_data/ld_reference.md">predefined LD blocks</a>.</p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">twas_z</span></code> is <code class="docutils literal notranslate"><span class="pre">NA</span></code> it means the context is not imputable for the method of choice</p>
<p>II. a list of  <code class="docutils literal notranslate"><span class="pre">refined_twas_weights_data</span></code> per block, in RDS format, of this structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ region_id
   $ gene 
      $ context
        $ selected_model
        $ is_imputable 
        $ selected_top_variants
        $ selected_model_weights

</pre></div>
</div>
<p>The twas result table will only contain imputatable genes. It should come with a meta-data file like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">chrom</span>    <span class="n">start</span>    <span class="n">end</span>    <span class="n">block_id</span>  <span class="n">refined_twas_db</span>
<span class="mi">1</span>        <span class="mi">1000</span>     <span class="mi">5000</span>   <span class="n">block1</span>    <span class="n">block1</span><span class="o">.</span><span class="n">rds</span>
<span class="mi">2</span>        <span class="mi">2000</span>     <span class="mi">6000</span>   <span class="n">block2</span>    <span class="n">block2</span><span class="o">.</span><span class="n">rds</span>
<span class="mi">3</span>        <span class="mi">3000</span>     <span class="mi">7000</span>   <span class="n">block3</span>    <span class="n">block3</span><span class="o">.</span><span class="n">rds</span>
</pre></div>
</div>
<section id="iii-run-twas">
<h3>iii. Run TWAS<a class="headerlink" href="#iii-run-twas" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-sos notranslate"><div class="highlight"><pre><span></span>sos run pipeline/twas_ctwas.ipynb twas \
   --cwd output/twas --name test \
   --gwas_meta_data data/twas/gwas_meta_test.tsv \
   --ld_meta_data reference_data/ADSP_R4_EUR/ld_meta_file.tsv \
   --regions data/twas/EUR_LD_blocks.bed \
   --xqtl_meta_data data/twas/mwe_twas_pipeline_test_small.tsv \
   --xqtl_type_table data/twas/data_type_table.txt \
   --rsq_pval_cutoff 0.05 --rsq_cutoff 0.01    
</pre></div>
</div>
</div>
</div>
</section>
<section id="iv-run-ctwas">
<h3>iv. Run cTWAS<a class="headerlink" href="#iv-run-ctwas" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-sos notranslate"><div class="highlight"><pre><span></span>sos run pipeline/twas_ctwas.ipynb ctwas \
   --cwd output/twas --name test \
   --gwas_meta_data data/twas/gwas_meta_test.tsv \
   --ld_meta_data data/ld_meta_file_with_bim.tsv \
   --xqtl_meta_data data/twas/mwe_twas_pipeline_test_small.tsv \
   --twas_weight_cutoff 0 \
   --chrom 11 \
   --regions data/twas/EUR_LD_blocks.bed \
   --region-name chr10_80126158_82231647 chr11_84267999_86714492
</pre></div>
</div>
</div>
</div>
<p>Here using <code class="docutils literal notranslate"><span class="pre">--region-name</span></code> we focus the analysis on 2 blocks: format as <code class="docutils literal notranslate"><span class="pre">chr_start_stop</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sos</span> <span class="n">run</span> <span class="n">xqtl</span><span class="o">-</span><span class="n">protocol</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">pecotmr_integration</span><span class="o">/</span><span class="n">twas</span><span class="o">.</span><span class="n">ipynb</span> <span class="n">quantile_twas</span> \
   <span class="o">--</span><span class="n">cwd</span> <span class="o">/</span><span class="n">output</span><span class="o">/</span> <span class="o">--</span><span class="n">name</span> <span class="n">test</span> \
   <span class="o">--</span><span class="n">gwas_meta_data</span> <span class="o">/</span><span class="n">mnt</span><span class="o">/</span><span class="n">vast</span><span class="o">/</span><span class="n">hpc</span><span class="o">/</span><span class="n">csg</span><span class="o">/</span><span class="n">cl4215</span><span class="o">/</span><span class="n">mrmash</span><span class="o">/</span><span class="n">workflow</span><span class="o">/</span><span class="n">GWAS</span><span class="o">/</span><span class="n">gwas_meta</span><span class="o">.</span><span class="n">tsv</span> \
   <span class="o">--</span><span class="n">ld_meta_data</span> <span class="o">/</span><span class="n">mnt</span><span class="o">/</span><span class="n">vast</span><span class="o">/</span><span class="n">hpc</span><span class="o">/</span><span class="n">csg</span><span class="o">/</span><span class="n">data_public</span><span class="o">/</span><span class="mi">20240409</span><span class="n">_ADSP_LD_matrix</span><span class="o">/</span><span class="n">ld_meta_file</span><span class="o">.</span><span class="n">tsv</span> \
   <span class="o">--</span><span class="n">region_name</span> <span class="n">chr11_84267999_86714492</span> <span class="n">chr7_54681006_57314931</span> \
   <span class="o">--</span><span class="n">xqtl_meta_data</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">al4225</span><span class="o">/</span><span class="n">project</span><span class="o">/</span><span class="n">quantile_twas</span><span class="o">/</span><span class="n">quantile_twas_analysis</span><span class="o">/</span><span class="n">test_data</span><span class="o">/</span><span class="n">small_region_gene_meta_data_test</span><span class="o">.</span><span class="n">tsv</span>
</pre></div>
</div>
<p>It is also possible to analyze a selected list of regions using option <code class="docutils literal notranslate"><span class="pre">--regions</span></code>. The 3 columns(chr, start, stop) of this file will be used for the block list to analyze. Here for example use the same list of regions as we used for LD block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sos</span> <span class="n">run</span> <span class="n">xqtl</span><span class="o">-</span><span class="n">protocol</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">pecotmr_integration</span><span class="o">/</span><span class="n">twas</span><span class="o">.</span><span class="n">ipynb</span> <span class="n">quantile_twas</span> \
   <span class="o">--</span><span class="n">cwd</span> <span class="o">/</span><span class="n">output</span><span class="o">/</span> <span class="o">--</span><span class="n">name</span> <span class="n">test</span> \
   <span class="o">--</span><span class="n">gwas_meta_data</span> <span class="o">/</span><span class="n">mnt</span><span class="o">/</span><span class="n">vast</span><span class="o">/</span><span class="n">hpc</span><span class="o">/</span><span class="n">csg</span><span class="o">/</span><span class="n">cl4215</span><span class="o">/</span><span class="n">mrmash</span><span class="o">/</span><span class="n">workflow</span><span class="o">/</span><span class="n">GWAS</span><span class="o">/</span><span class="n">gwas_meta</span><span class="o">.</span><span class="n">tsv</span> \
   <span class="o">--</span><span class="n">ld_meta_data</span> <span class="o">/</span><span class="n">mnt</span><span class="o">/</span><span class="n">vast</span><span class="o">/</span><span class="n">hpc</span><span class="o">/</span><span class="n">csg</span><span class="o">/</span><span class="n">data_public</span><span class="o">/</span><span class="mi">20240409</span><span class="n">_ADSP_LD_matrix</span><span class="o">/</span><span class="n">ld_meta_file</span><span class="o">.</span><span class="n">tsv</span> \
   <span class="o">--</span><span class="n">regions</span> <span class="o">/</span><span class="n">mnt</span><span class="o">/</span><span class="n">vast</span><span class="o">/</span><span class="n">hpc</span><span class="o">/</span><span class="n">csg</span><span class="o">/</span><span class="n">cl4215</span><span class="o">/</span><span class="n">mrmash</span><span class="o">/</span><span class="n">workflow</span><span class="o">/</span><span class="n">pipeline_data</span><span class="o">/</span><span class="n">EUR_LD_blocks</span><span class="o">.</span><span class="n">bed</span> \
   <span class="o">--</span><span class="n">xqtl_meta_data</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">al4225</span><span class="o">/</span><span class="n">project</span><span class="o">/</span><span class="n">quantile_twas</span><span class="o">/</span><span class="n">quantile_twas_analysis</span><span class="o">/</span><span class="n">test_data</span><span class="o">/</span><span class="n">small_region_gene_meta_data_test</span><span class="o">.</span><span class="n">tsv</span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-sos notranslate"><div class="highlight"><pre><span></span>[global]
parameter: cwd = path(&quot;output/&quot;)
parameter: gwas_meta_data = path()
parameter: xqtl_meta_data = path()
parameter: ld_meta_data = path()
parameter: xqtl_type_table = &#39;&#39;
parameter: gwas_name = []
parameter: gwas_data = []
parameter: column_mapping = []
parameter: regions = path()
# Optional: if a region name is provided 
# the analysis would be focused on the union of provides region list and region names
parameter: region_name = []
parameter: name = f&quot;{xqtl_meta_data:bn}.{gwas_meta_data:bn}&quot;
parameter: container = &#39;&#39;
import re
parameter: entrypoint= (&#39;micromamba run -a &quot;&quot; -n&#39; + &#39; &#39; + re.sub(r&#39;(_apptainer:latest|_docker:latest|\.sif)$&#39;, &#39;&#39;, container.split(&#39;/&#39;)[-1])) if container else &quot;&quot;
parameter: job_size = 100
parameter: walltime = &quot;5m&quot;
parameter: mem = &quot;8G&quot;
parameter: numThreads = 1
# name suffix add to end of the name variable for the output files 
parameter: name_suffix = &quot;&quot;
# optional parameter in ctwas to only perform gwas specific analysis 
parameter: gwas_study=[]

import os
import pandas as pd

def adapt_file_path(file_path, reference_file):
    &quot;&quot;&quot;
    Adapt a single file path based on its existence and a reference file&#39;s path.

    Args:
    - file_path (str): The file path to adapt.
    - reference_file (str): File path to use as a reference for adaptation.

    Returns:
    - str: Adapted file path.

    Raises:
    - FileNotFoundError: If no valid file path is found.
    &quot;&quot;&quot;
    reference_path = os.path.dirname(reference_file)

    # Check if the file exists
    if os.path.isfile(file_path):
        return file_path

    # Check file name without path
    file_name = os.path.basename(file_path)
    if os.path.isfile(file_name):
        return file_name

    # Check file name in reference file&#39;s directory
    file_in_ref_dir = os.path.join(reference_path, file_name)
    if os.path.isfile(file_in_ref_dir):
        return file_in_ref_dir

    # Check original file path prefixed with reference file&#39;s directory
    file_prefixed = os.path.join(reference_path, file_path)
    if os.path.isfile(file_prefixed):
        return file_prefixed

    # If all checks fail, raise an error
    raise FileNotFoundError(f&quot;No valid path found for file: {file_path}&quot;)

def group_by_region(lst, partition):
    # from itertools import accumulate
    # partition = [len(x) for x in partition]
    # Compute the cumulative sums once
    # cumsum_vector = list(accumulate(partition))
    # Use slicing based on the cumulative sums
    # return [lst[(cumsum_vector[i-1] if i &gt; 0 else 0):cumsum_vector[i]] for i in range(len(partition))]
    return partition
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-sos notranslate"><div class="highlight"><pre><span></span>[get_analysis_regions: shared = [&quot;filtered_region_info&quot;, &quot;filtered_regional_xqtl_files&quot;, &quot;regional_data&quot;]]
from collections import OrderedDict

def check_required_columns(df, required_columns):
    &quot;&quot;&quot;Check if the required columns are present in the dataframe.&quot;&quot;&quot;
    missing_columns = [col for col in required_columns if col not in list(df.columns)]
    if missing_columns:
        raise ValueError(f&quot;Missing required columns: {&#39;, &#39;.join(missing_columns)}&quot;)

def extract_regional_data(gwas_meta_data, xqtl_meta_data, regions, region_name, gwas_name, gwas_data, column_mapping):
    &quot;&quot;&quot;
    Extracts data from GWAS and xQTL metadata files and additional GWAS data provided. 

    Args:
    - gwas_meta_data (str): File path to the GWAS metadata file.
    - xqtl_meta_data (str): File path to the xQTL weight metadata file.
    - gwas_name (list): vector of GWAS study names.
    - gwas_data (list): vector of GWAS data.
    - column_mapping (list, optional): vector of column mapping files.

    Returns:
    - Tuple of two dictionaries:
        - GWAS Dictionary: Maps study IDs to a list containing chromosome number, 
          GWAS file path, and optional column mapping file path.
        - xQTL Dictionary: Nested dictionary with region IDs as keys.

    Raises:
    - FileNotFoundError: If any specified file path does not exist.
    - ValueError: If required columns are missing in the input files or vector lengths mismatch.
    &quot;&quot;&quot;
    # Check vector lengths
    if len(gwas_name) != len(gwas_data):
        raise ValueError(&quot;gwas_name and gwas_data must be of equal length&quot;)
    
    if len(column_mapping)&gt;0 and len(column_mapping) != len(gwas_name):
        raise ValueError(&quot;If column_mapping is provided, it must be of the same length as gwas_name and gwas_data&quot;)

    # Required columns for each file type
    required_gwas_columns = [&#39;study_id&#39;, &#39;chrom&#39;, &#39;file_path&#39;]
    required_xqtl_columns = [&#39;region_id&#39;, &#39;#chr&#39;, &#39;start&#39;, &#39;end&#39;, &quot;TSS&quot;, &#39;original_data&#39;] #region_id here is gene name
    required_ld_columns = [&#39;chr&#39;, &#39;start&#39;, &#39;stop&#39;]
    
    # Reading the GWAS metadata file
    gwas_df = pd.read_csv(gwas_meta_data, sep=&quot;\t&quot;)
    check_required_columns(gwas_df, required_gwas_columns)
    gwas_dict = OrderedDict()
    
    # Reading LD regions info
    # Initialize empty DataFrame for regions
    regions_df = pd.DataFrame(columns=[&#39;chr&#39;, &#39;start&#39;, &#39;stop&#39;])

    # Check if regions file exists and read it
    if os.path.isfile(regions):
        file_regions_df = pd.read_csv(regions, sep=&quot;\t&quot;, skipinitialspace=True)
        file_regions_df.columns = [col.strip() for col in file_regions_df.columns]  # Strip spaces from column names
        file_regions_df[&#39;chr&#39;] = file_regions_df[&#39;chr&#39;].str.strip()
        check_required_columns(file_regions_df, required_ld_columns)
        regions_df = pd.concat([regions_df, file_regions_df])
    # Process region_name if provided: 
    # fomat: region_name = [&quot;chr1_16103_2888443&quot;, &quot;chr1_4320284_5853833&quot;]
    if len(region_name) &gt; 0:
        # Split region_name entries into chr, start, and stop columns
        extra_regions = [name.split(&quot;_&quot;) for name in region_name]
        extra_regions_df = pd.DataFrame(extra_regions, columns=[&#39;chr&#39;, &#39;start&#39;, &#39;stop&#39;])
        extra_regions_df[&#39;start&#39;] = extra_regions_df[&#39;start&#39;].astype(int)
        extra_regions_df[&#39;stop&#39;] = extra_regions_df[&#39;stop&#39;].astype(int)
        # Add extra regions to regions_df
        regions_df = pd.concat([regions_df, extra_regions_df])
    # Remove duplicates and reset index
    regions_df = regions_df.drop_duplicates().reset_index(drop=True)
    regions_dict = OrderedDict()

    # Reading the xQTL weight metadata file
    xqtl_df = pd.read_csv(xqtl_meta_data, sep=&quot; &quot;)
    check_required_columns(xqtl_df, required_xqtl_columns)
    xqtl_dict = OrderedDict()

    # Process additional GWAS data from R vectors
    for name, data, mapping in zip(gwas_name, gwas_data, column_mapping or [None]*len(gwas_name)):
        gwas_dict[name] = {0: [data, mapping]}

    for _, row in gwas_df.iterrows():
        file_path = row[&#39;file_path&#39;]
        mapping_file = row.get(&#39;column_mapping_file&#39;)
        
        # Adjust paths if necessary
        file_path = adapt_file_path(file_path, gwas_meta_data)
        if mapping_file:
            mapping_file = adapt_file_path(mapping_file,  gwas_meta_data)

       # Create or update the entry for the study_id
        if row[&#39;study_id&#39;] not in gwas_dict:
            gwas_dict[row[&#39;study_id&#39;]] = {}

        # Expand chrom 0 to chrom 1-22 or use the specified chrom
        chrom_range = range(1, 23) if row[&#39;chrom&#39;] == 0 else [row[&#39;chrom&#39;]]
        for chrom in chrom_range:
            if chrom in gwas_dict[row[&#39;study_id&#39;]]:
                existing_entry = gwas_dict[row[&#39;study_id&#39;]][f&#39;chr{chrom}&#39;]
                raise ValueError(f&quot;Duplicate chromosome specification for study_id {row[&#39;study_id&#39;]}, chrom {chrom}. &quot;
                                 f&quot;Conflicting entries: {existing_entry} and {[file_path, mapping_file]}&quot;)
            gwas_dict[row[&#39;study_id&#39;]][f&#39;chr{chrom}&#39;] = [file_path, mapping_file]
            
    for _, row in regions_df.iterrows():
        LD_region_id = f&quot;{row[&#39;chr&#39;]}_{row[&#39;start&#39;]}_{row[&#39;stop&#39;]}&quot;
        overlapping_xqtls = xqtl_df[(xqtl_df[&#39;#chr&#39;] == row[&#39;chr&#39;]) &amp; 
                                     (xqtl_df[&#39;TSS&#39;] &lt;= row[&#39;stop&#39;]) &amp; 
                                     (xqtl_df[&#39;TSS&#39;] &gt;= (row[&#39;start&#39;]))]
        file_paths = []
        mapped_genes = []
        # Collect file paths for xQTLs overlapping this region
        for _, xqtl_row in overlapping_xqtls.iterrows():
            original_data = xqtl_row[&#39;original_data&#39;]
            file_list = original_data.split(&#39;,&#39;) if &#39;,&#39; in original_data else [original_data]
            file_paths.extend([adapt_file_path(fp.strip(), xqtl_meta_data) for fp in file_list])
            mapped_genes.extend([xqtl_row[&#39;region_id&#39;]] * len(file_list))

        # Store metadata and files in the dictionary
        regions_dict[LD_region_id] = {
            &quot;meta_info&quot;: [row[&#39;chr&#39;], row[&#39;start&#39;], row[&#39;stop&#39;], LD_region_id, mapped_genes],
            &quot;files&quot;: file_paths
        }
        
    for _, row in xqtl_df.iterrows():
        file_paths = [adapt_file_path(fp.strip(), xqtl_meta_data) for fp in row[&#39;original_data&#39;].split(&#39;,&#39;)]  # Splitting and stripping file paths
        xqtl_dict[row[&#39;region_id&#39;]] = {&quot;meta_info&quot;: [row[&#39;#chr&#39;], row[&#39;start&#39;], row[&#39;end&#39;], row[&#39;region_id&#39;], row[&#39;contexts&#39;]],
                                       &quot;files&quot;: file_paths}
    return gwas_dict, xqtl_dict, regions_dict


gwas_dict, xqtl_dict, regions_dict = extract_regional_data(gwas_meta_data, xqtl_meta_data,regions,region_name,gwas_name, gwas_data, column_mapping)
regional_data = dict([(&quot;GWAS&quot;, gwas_dict), (&quot;xQTL&quot;, xqtl_dict), (&quot;Regions&quot;, regions_dict)])


# get regions data 
region_info = [x[&quot;meta_info&quot;] for x in regional_data[&#39;Regions&#39;].values()]
regional_xqtl_files = [x[&quot;files&quot;] for x in regional_data[&#39;Regions&#39;].values()]

# Filter out empty xQTL file paths
filtered_region_info = []
filtered_regional_xqtl_files = []
skipped_regions =[]

for region, files in zip(region_info, regional_xqtl_files):
    if files:
        filtered_region_info.append(region)
        filtered_regional_xqtl_files.append(files)
    else:
        skipped_regions.append(region)
print(f&quot;Skipping {len(skipped_regions)} out of {len(regional_xqtl_files)} regions, no overlapping xQTL weights found. &quot;)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-sos notranslate"><div class="highlight"><pre><span></span>[twas]
depends: sos_variable(&quot;filtered_regional_xqtl_files&quot;)
parameter: coverage = &quot;cs_coverage_0.95&quot;
# Threshold for rsq and pvalue for imputability determination for a model 
parameter: rsq_cutoff = 0.01
parameter: rsq_pval_cutoff = 0.05
parameter: mr_pval_cutoff = 0.05
parameter: save_ctwas_data = True
parameter: save_mr_result = True
parameter: rsq_option=&quot;rsq&quot;
parameter: rsq_pval_option=[&quot;adj_rsq_pval&quot;, &quot;pval&quot;]
# load by batches if memory resource is limited, default to load all at once 
parameter: batch_load_memory = 500
parameter: event_filter_rules = path()
parameter: comment_string = &quot;NULL&quot;
parameter: rename_column = False
input: filtered_regional_xqtl_files, group_by = lambda x: group_by_region(x, filtered_regional_xqtl_files), group_with = &quot;filtered_region_info&quot;
output_files = [f&#39;{cwd:a}/{step_name}/{name}.{_filtered_region_info[3]}.twas.tsv.gz&#39;]
if save_ctwas_data:
    output_files.append(f&#39;{cwd:a}/{step_name}/{name}.{_filtered_region_info[3]}.twas_data.rds&#39;)
if save_mr_result:
    output_files.append(f&#39;{cwd:a}/{step_name}/{name}.{_filtered_region_info[3]}.mr_result.tsv.gz&#39;)
output: output_files
task: trunk_workers = 1, trunk_size = job_size, walltime = walltime, mem = mem, cores = numThreads, tags = f&#39;{step_name}_{_output[0]:bn}&#39;
R: expand = &#39;${ }&#39;, stdout = f&quot;{_output[0]:n}.stdout&quot;, stderr = f&quot;{_output[0]:n}.stderr&quot;, container = container, entrypoint = entrypoint

    library(dplyr)
    library(data.table)
    library(pecotmr)
    library(readr)



    # Load metadata and configuration - let these fail if there are issues
    if (${&quot;TRUE&quot; if rename_column else &quot;FALSE&quot;}) {
        gwas_meta_data = fread(&quot;${gwas_meta_data}&quot;, data.table=FALSE)
        column_file_path = gwas_meta_data$column_mapping[1]
    } else {
        column_file_path = NULL
    }
    
    xqtl_meta_df &lt;- fread(&quot;${xqtl_meta_data}&quot;, data.table=FALSE)
    xqtl_type_table &lt;- if (isTRUE(file.exists(&quot;${xqtl_type_table}&quot;))) fread(&quot;${xqtl_type_table}&quot;) else NULL
    gene_list &lt;- c(${&#39;, &#39;.join([f&quot;&#39;{gene}&#39;&quot; for gene in _filtered_region_info[4]])})
    
    event_filter_rules = ${&quot;NULL&quot; if not event_filter_rules.is_file() else &quot;&#39;%s&#39;&quot; % event_filter_rules}
    if (!is.null(event_filter_rules)) {
        event_filters &lt;- read.table(&quot;${event_filter_rules}&quot;)
        event_filters &lt;- lapply(1:nrow(event_filters), function(ii) as.list(event_filters[ii,] %&gt;% unlist))
    } else { 
        event_filters &lt;- NULL 
    }

    # Process weights with targeted error handling for file operations
    weight_db_list &lt;- c(${_input:r,})
    names(weight_db_list) &lt;- gene_list
    weight_db_list &lt;- split(weight_db_list, names(weight_db_list))
    
    # Filter out empty/invalid weight files with error handling
    weight_db_list_update &lt;- tryCatch({
        Filter(Negate(is.null), lapply(weight_db_list, function(file_list) {
            do.call(c, lapply(file_list, function(file) {
                if (file.exists(file) &amp;&amp; file.size(file) &gt; 200) file else NULL
            }))
        }))
    }, error = function(e) {
        message(paste(&quot;Error checking weight files:&quot;, e$message))
        return(list())
    })
    
    if(length(weight_db_list_update) &lt;= 0) {
        message(paste0(&quot;No valid weight files for region ${_filtered_region_info[3]}. Creating empty output files.&quot;))
        # Define TWAS result columns (same as in final_results)
        twas_header &lt;- data.frame(
            gene = character(),
            molecular_id = character(),
            TSS = numeric(),
            start = numeric(),
            end = numeric(),
            beta = numeric(),
            se = numeric(),
            z = numeric(),
            pval = numeric(),
            qval = numeric(),
            rsq = numeric(),
            mr_beta = numeric(),
            mr_se = numeric(),
            mr_pval = numeric()
        )

        # Write empty file with header, gzipped
        fwrite(twas_header, file = ${_output[0]:r}, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
        if (${&quot;TRUE&quot; if save_ctwas_data else &quot;FALSE&quot;}) {
            saveRDS(list(), &quot;${_output[0]:nnn}.twas_data.rds&quot;, compress=&#39;xz&#39;)
        }
        if (${&quot;TRUE&quot; if save_mr_result else &quot;FALSE&quot;}) {
            fwrite(data.frame(), file = &quot;${_output[0]:nnn}.mr_result.tsv.gz&quot;, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
        }
        quit(save = &quot;no&quot;, status = 0)
    }

    # Load TWAS weights - allow this to fail with informative errors
    message(paste(&quot;Loading TWAS weights for&quot;, length(weight_db_list_update), &quot;genes&quot;))
    twas_weights_results &lt;- list()
    
    for (gene_db in names(weight_db_list_update)) {
        weight_dbs &lt;- weight_db_list_update[[gene_db]]
        message(paste(&quot;Processing gene:&quot;, gene_db, &quot;with&quot;, length(weight_dbs), &quot;weight files&quot;))
        
        # Load weights for this gene - let it fail if there are real issues
        twas_weights_results[[gene_db]] = load_twas_weights(
            weight_dbs, 
            variable_name_obj = &quot;variant_names&quot;, 
            susie_obj = &quot;susie_weights_intermediate&quot;,
            twas_weights_table = &quot;twas_weights&quot;
        )
        
        if (length(twas_weights_results[[gene_db]]) &gt; 1) {
            twas_weights_results[[gene_db]]$data_type &lt;- setNames(
                lapply(names(twas_weights_results[[gene_db]]$weights), function(context) {
                    xqtl_type_table$type[sapply(xqtl_type_table$context, function(x) grepl(x, context))]
                }), 
                names(twas_weights_results[[gene_db]]$weights)
            )      
        } else {
            message(paste(&quot;No valid weights loaded for gene:&quot;, gene_db))
            twas_weights_results[[gene_db]] &lt;- NULL
        }                   
    }
    
    # Clean up and check if we have any valid results
    rm(weight_db_list, weight_db_list_update, xqtl_type_table, gene_list)
    gc()
    
    # Filter out NULL results and report
    valid_genes &lt;- names(Filter(Negate(is.null), twas_weights_results))
    message(paste(&quot;Valid weights loaded for&quot;, length(valid_genes), &quot;genes:&quot;, paste(valid_genes, collapse = &quot;, &quot;)))
    
    if (length(valid_genes) == 0) {
        message(paste0(&quot;No valid TWAS weights loaded for region ${_filtered_region_info[3]}. Creating empty output files.&quot;))
        fwrite(data.frame(), file = ${_output[0]:r}, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
        if (${&quot;TRUE&quot; if save_ctwas_data else &quot;FALSE&quot;}) {
            saveRDS(list(), &quot;${_output[0]:nnn}.twas_data.rds&quot;, compress=&#39;xz&#39;)
        }
        if (${&quot;TRUE&quot; if save_mr_result else &quot;FALSE&quot;}) {
            fwrite(data.frame(), file = &quot;${_output[0]:nnn}.mr_result.tsv.gz&quot;, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
        }
        quit(save = &quot;no&quot;, status = 0)
    }

    # Batch load weights - allow this to fail
    twas_weights_results &lt;- batch_load_twas_weights(
        twas_weights_results = twas_weights_results,
        meta_data_df = xqtl_meta_df,
        max_memory_per_batch = ${&quot;Inf&quot; if batch_load_memory == &quot;inf&quot; else batch_load_memory}
    )
    
    message(paste(&quot;Proceeding with TWAS analysis for&quot;, length(twas_weights_results), &quot;batches&quot;))

    # TWAS analysis - allow this to fail with informative errors
    twas_results_db &lt;- list()
    for (batch in 1:length(twas_weights_results)){
        message(paste(&quot;Processing batch&quot;, batch, &quot;of&quot;, length(twas_weights_results)))
        
        twas_results_db[[batch]] &lt;- twas_pipeline(
            twas_weights_results[[batch]], 
            &quot;${ld_meta_data}&quot;, 
            &quot;${gwas_meta_data}&quot;,  
            region_block = &quot;${_filtered_region_info[3]}&quot;,
            rsq_cutoff = ${rsq_cutoff}, 
            rsq_option = &quot;${rsq_option}&quot;, 
            rsq_pval_cutoff = ${rsq_pval_cutoff}, 
            rsq_pval_option = c(${&quot;, &quot;.join([f&#39;&quot;{x}&quot;&#39; for x in rsq_pval_option])}), 
            mr_pval_cutoff = ${mr_pval_cutoff},
            mr_coverage_column = &quot;${coverage}&quot;, 
            output_twas_data = ${&quot;TRUE&quot; if save_ctwas_data else &quot;FALSE&quot;},
            event_filters = event_filters,
            column_file_path = column_file_path,
            comment_string = ${&quot;NULL&quot; if comment_string == &quot;NULL&quot; else f&quot;&#39;{comment_string}&#39;&quot;}
        )
        
        # Report batch results
        if (!is.null(twas_results_db[[batch]])) {
            if (!is.null(twas_results_db[[batch]]$twas_result)) {
                message(paste(&quot;Batch&quot;, batch, &quot;produced&quot;, nrow(twas_results_db[[batch]]$twas_result), &quot;TWAS results&quot;))
            } else {
                message(paste(&quot;Batch&quot;, batch, &quot;produced NULL twas_result&quot;))
            }
        } else {
            message(paste(&quot;Batch&quot;, batch, &quot;produced NULL results&quot;))
        }
    }
    
    rm(twas_weights_results)
    gc()
    
    # Filter and report final results
    twas_results_db &lt;- Filter(Negate(is.null), twas_results_db)
    message(paste(&quot;Final valid batches:&quot;, length(twas_results_db)))

    if(length(twas_results_db) != 0){
        # Merge with metadata
        for (batch in 1:length(twas_results_db)){
            if (!is.null(twas_results_db[[batch]]$twas_result)) {
                twas_results_db[[batch]]$twas_result &lt;- merge(
                    twas_results_db[[batch]]$twas_result, 
                    xqtl_meta_df[, c(&quot;region_id&quot;,&quot;TSS&quot;,&quot;start&quot;,&quot;end&quot;)], 
                    by.x = &quot;molecular_id&quot;, by.y = &quot;region_id&quot;
                )
            }
        }
        
        # Combine and write results
        final_results &lt;- do.call(rbind, lapply(twas_results_db, function(x) {
            if (!is.null(x$twas_result)) x$twas_result[, c(2,1,14:16,3:13)] else data.frame()
        }))
        
        message(paste(&quot;Writing&quot;, nrow(final_results), &quot;final TWAS results&quot;))
        fwrite(final_results, ${_output[0]:r}, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
    } else {
        message(&quot;No valid TWAS results to write&quot;)
        fwrite(data.frame(), file = ${_output[0]:r}, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
    }

    # Save cTWAS data if requested
    if (${&quot;TRUE&quot; if save_ctwas_data else &quot;FALSE&quot;} &amp; length(twas_results_db) != 0) {
        if (length(twas_results_db) &gt; 1){
            # Combine data from multiple batches
            twas_results_db[[1]]$twas_data$weights &lt;- do.call(c, lapply(twas_results_db, function(x) x$twas_data$weights))
            twas_results_db[[1]]$twas_data$susie_weights_intermediate_qced &lt;- do.call(c, lapply(twas_results_db, function(x) x$twas_data$susie_weights_intermediate_qced))
            studies &lt;- unique(names(find_data(twas_results_db, c(3, &quot;z_gene&quot;))))
            for (study in studies){
                twas_results_db[[1]][[&quot;twas_data&quot;]][[&quot;z_gene&quot;]][[study]] &lt;- do.call(rbind, lapply(twas_results_db, function(x) x$twas_data$z_gene[[study]]))
            }
        }
        saveRDS(twas_results_db[[1]]$twas_data, &quot;${_output[0]:nnn}.twas_data.rds&quot;, compress=&#39;xz&#39;)
    } else if (${&quot;TRUE&quot; if save_ctwas_data else &quot;FALSE&quot;}) {
        saveRDS(list(), &quot;${_output[0]:nnn}.twas_data.rds&quot;, compress=&#39;xz&#39;)
    }

    # Save MR results if requested
    if (${&quot;TRUE&quot; if save_mr_result else &quot;FALSE&quot;}) {
        if(length(twas_results_db) != 0) {
            mr_results &lt;- do.call(rbind, lapply(twas_results_db, function(x) x$mr_result))
            message(paste(&quot;Writing&quot;, nrow(mr_results), &quot;MR results&quot;))
            fwrite(mr_results, file = &quot;${_output[0]:nnn}.mr_result.tsv.gz&quot;, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
        } else {
            fwrite(data.frame(), file = &quot;${_output[0]:nnn}.mr_result.tsv.gz&quot;, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
        }
    }

    message(&quot;TWAS analysis completed successfully&quot;)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-sos notranslate"><div class="highlight"><pre><span></span>[ctwas_1]
# ctwas_1: merge regions by each chromosome 
depends: sos_variable(&quot;filtered_region_info&quot;)
# chromosome number to merge for region data, can be an integer or a string, i.e. &#39;chr1&#39;
parameter: chrom=&quot;&quot;
# twas weight cutoff for ctwas variant selection
parameter: twas_weight_cutoff = 0.0
parameter: max_num_variants =&quot;Inf&quot;
# cs_min_cor cutoff in susie finemapping result for variant selection
parameter: cs_min_cor = 0
# minimum pip cutoff in susie finemapping result for variant selection
parameter: min_pip_cutoff =0 
# A scalar in (0,1]. The proportion of SNPs, reduce runtime at the cost of accuracy 
parameter: thin = 1.0
# Maximum number of SNPs in a region.
parameter: maxSNP = 20000
# skip this step if True
parameter: skip_assembly = False
skip_if(skip_assembly == True, &quot; Skip [ctwas_1] assemble regions. &quot; )
parameter: multi_group = True
# A string character add to the end of name variable
parameter: numThreads = 4

twas_output_files = {}
region_blocks_per_chrom = []
chromosome_list = []
chrom = f&quot;chr{int(chrom)}&quot; if str(chrom).isdigit() else chrom
for region_info in filtered_region_info:
    chrom_info = region_info[0]
    if chrom_info != chrom:
        continue  # Skip chromosomes other than chrom input 
    file_path = f&quot;{cwd}/twas/{name}.{region_info[3]}.twas_data.rds&quot;
    if chrom_info not in twas_output_files:
        twas_output_files[chrom_info] = [[], []]  # Structure: {&quot;chrX&quot;: [[files], [region_names]]}
        chromosome_list.append(chrom_info)
    twas_output_files[chrom_info][0].append(file_path)  # File paths
    twas_output_files[chrom_info][1].append(region_info[3])  # Region names
twas_files=[twas_output_files[chr][0] for chr in chromosome_list]

region_blocks_per_chrom = [twas_output_files[chr][1] for chr in chromosome_list]
region_blocks_per_chrom = [f&quot;&quot;&quot;c(&quot;{&#39;&quot;, &quot;&#39;.join(regions)}&quot;)&quot;&quot;&quot; for regions in region_blocks_per_chrom]
outdir = f&quot;{cwd}/{step_name.split(&#39;_&#39;)[0]}&quot;
if not os.path.exists(outdir):
    os.makedirs(outdir)
gwas_study = &#39;c(&#39; + &#39;, &#39;.join(f&#39;&quot;{x}&quot;&#39; for x in gwas_study) + &#39;)&#39;
name_suffix = f&#39;&quot;{name_suffix}&quot;&#39; if name_suffix else &#39;NULL&#39;

input: twas_files, group_by = lambda x: group_by_region(x, twas_files),  group_with=dict(region_names=region_blocks_per_chrom)
task: trunk_workers = 1, trunk_size = job_size, walltime = walltime, mem = mem, cores = numThreads
R: expand = &#39;${ }&#39;, stdout = f&quot;{cwd:a}/{step_name.split(&#39;_&#39;)[0]}/{name}.ctwas_region_data.{chrom}.thin{thin}.stdout&quot;, 
stderr = f&quot;{cwd:a}/{step_name.split(&#39;_&#39;)[0]}/{name}.ctwas_region_data.{chrom}.thin{thin}.stderr&quot;, container = container, entrypoint = entrypoint

    library(data.table)
    library(ctwas) # multigroup_ctwas
    library(pecotmr)
    library(stringr)
    outputdir = &quot;${cwd:a}/${step_name.split(&#39;_&#39;)[0]}&quot;
    
    # load genome-wide data across all regions
    gwas_meta_data &lt;- fread(&quot;${gwas_meta_data}&quot;,data.table=FALSE)
    gwas_studies &lt;- if (length(${gwas_study})!=0) ${gwas_study} else unique(gwas_meta_data$study_id)
    gwas_files &lt;- gwas_meta_data[gwas_meta_data$chrom == readr::parse_number(&quot;${chrom}&quot;) &amp; gwas_meta_data$study_id %in% gwas_studies,, drop=FALSE]
    gwas_files &lt;- setNames(gwas_files$file_path, gwas_files$study_id)

    merge_context_names &lt;- function(ctwas_dat_file){
        ctwas_dat&lt;- readRDS(ctwas_dat_file)
        idxs &lt;- which(grepl(&quot;_chr[0-9XY]+_[^_]+&quot;, names(ctwas_dat$weights)))
        if (length(idxs)&gt;0) {
            names(ctwas_dat$weights) &lt;- gsub(&quot;_chr[0-9XY]+_[A-Za-z0-9]+&quot;, &quot;&quot;, names(ctwas_dat$weights))
            for (idx in idxs) {
                for (study in names(ctwas_dat$weights[[idx]])){
                    ctwas_dat$weights[[idx]][[study]]$weight_name &lt;- gsub(&quot;_chr[0-9XY]+_[A-Za-z0-9]+&quot;, &quot;&quot;, ctwas_dat$weights[[idx]][[study]]$weight_name)
                    ctwas_dat$weights[[idx]][[study]]$context &lt;- gsub(&quot;_chr[0-9XY]+_[A-Za-z0-9]+&quot;, &quot;&quot;, ctwas_dat$weights[[idx]][[study]]$context)
                }
            }
            for (study in names(ctwas_dat$z_gene)){
                ctwas_dat$z_gene[[study]]$id &lt;- gsub(&quot;_chr[0-9XY]+_[A-Za-z0-9]+&quot;, &quot;&quot;, ctwas_dat$z_gene[[study]]$id)
                ctwas_dat$z_gene[[study]]$context &lt;- gsub(&quot;_chr[0-9XY]+_[A-Za-z0-9]+&quot;, &quot;&quot;, ctwas_dat$z_gene[[study]]$context)
                ctwas_dat$z_gene[[study]]$group &lt;- gsub(&quot;_chr[0-9XY]+_[A-Za-z0-9]+&quot;, &quot;&quot;, ctwas_dat$z_gene[[study]]$group)
            }
            for (gene in names(ctwas_dat$susie_weights_intermediate_qced)){
                names(ctwas_dat$susie_weights_intermediate_qced[[gene]]) &lt;-  gsub(&quot;_chr[0-9XY]+_[^_]+&quot;, &quot;&quot;, names(ctwas_dat$susie_weights_intermediate_qced[[gene]]))
            }
        }
        idxs &lt;- which(grepl(&quot;monocyte&quot;, names(ctwas_dat$weights)))
        if (length(idxs)&gt;0) {
            names(ctwas_dat$weights) &lt;- gsub(&quot;monocyte_eQTL&quot;, &quot;eQTL&quot;, names(ctwas_dat$weights))
            for (idx in idxs) {
                for (study in names(ctwas_dat$weights[[idx]])){
                    ctwas_dat$weights[[idx]][[study]]$weight_name &lt;- gsub(&quot;monocyte_eQTL&quot;, &quot;eQTL&quot;, ctwas_dat$weights[[idx]][[study]]$weight_name)
                    ctwas_dat$weights[[idx]][[study]]$type &lt;- &quot;eQTL&quot;
                }
            }
            for (study in names(ctwas_dat$z_gene)){
                ctwas_dat$z_gene[[study]]$id &lt;- gsub(&quot;monocyte_eQTL&quot;, &quot;eQTL&quot;, ctwas_dat$z_gene[[study]]$id)
                ctwas_dat$z_gene[[study]]$type &lt;- gsub(&quot;monocyte_&quot;, &quot;&quot;, ctwas_dat$z_gene[[study]]$type)
                ctwas_dat$z_gene[[study]]$group &lt;- gsub(&quot;monocyte_eQTL&quot;, &quot;eQTL&quot;, ctwas_dat$z_gene[[study]]$group)
            }
        }
        return(ctwas_dat)
    }
    weight_list = vector(&quot;list&quot;, length(gwas_studies))
    names(weight_list) &lt;- gwas_studies
    z_gene &lt;- weight_list  # empty list  
    z_snp &lt;- weight_list
    
    # get LD snp info table (snp_map) and ld variants 
    max_pos &lt;- fread(&quot;${ld_meta_data}&quot;, data.table=FALSE)
    max_pos &lt;- max(max_pos$end[max_pos[,1]==&quot;${chrom}&quot;])
    region_of_interest &lt;- data.frame(chrom = &quot;${chrom}&quot;, start = 0, end = max_pos+1)
    snp_map &lt;- load_ld_snp_info(&quot;${ld_meta_data}&quot;, region_of_interest)
    ld_variants &lt;- paste0(&quot;chr&quot;, unlist(lapply(snp_map, function(x) x$id)))
    ld_variants &lt;- ld_variants[!duplicated(ld_variants)]

    regions_data &lt;- get_ctwas_meta_data(&quot;${ld_meta_data}&quot;, names(snp_map))
    region_info &lt;- regions_data$region_info
    LD_map &lt;- regions_data$LD_info
    if (!is.null(${name_suffix})) name &lt;- paste0(&quot;${name}_&quot;, ${name_suffix})  else name &lt;- &quot;${name}&quot;
    if (!file.exists(file.path(outputdir, paste0(name, &quot;.LD_map.rds&quot;)))) saveRDS(LD_map, file.path(outputdir, paste0(name, &quot;.LD_map.rds&quot;)), compress=&#39;xz&#39;)
    saveRDS(snp_map, file.path(outputdir, paste0(name, &quot;.snp_map.${chrom}.rds&quot;)), compress=&#39;xz&#39;)
    rm(regions_data, LD_map)
    gc()
    region_map &lt;- c()
    # merge chromosome wide data, weight, z_gene, z_snp from the twas pipeline output of twas.data.rds files 
    for (region_dat in c(${_input:r,})){
        ctwas_dat &lt;- merge_context_names(region_dat)
        if (is.null(ctwas_dat)) next 
        weight_tmp &lt;- trim_ctwas_variants(ctwas_dat, twas_weight_cutoff=${twas_weight_cutoff}, cs_min_cor=${cs_min_cor},
                            min_pip_cutoff=${min_pip_cutoff}, max_num_variants=${max_num_variants})
        if (length(weight_tmp)==0) next 
        for (study in names(weight_tmp)) {
            if (!study %in% gwas_studies) next
            weight_list[[study]] &lt;- c(weight_list[[study]], weight_tmp[[study]])
            z_gene[[study]] &lt;- rbind(z_gene[[study]], ctwas_dat$z_gene[[study]])
            z_gene[[study]] &lt;- z_gene[[study]][!is.na(z_gene[[study]]$z) &amp; !is.infinite(z_gene[[study]]$z) &amp; z_gene[[study]]$id %in% names(weight_list[[study]]),]        
        }
        region &lt;- str_extract(region_dat, &quot;chr[0-9XY]+_[0-9]+_[0-9]+&quot;)
        z_genes &lt;- unique(find_data(weight_tmp, c(3, &quot;molecular_id&quot;)))
        names(z_genes) &lt;- rep(str_extract(region_dat, &quot;chr[0-9XY]+_[0-9]+_[0-9]+&quot;), length(z_genes))
        region_map &lt;- c(region_map, z_genes)
        rm(ctwas_dat, weight_tmp, z_genes, region)
        gc()
    }
    z_gene &lt;- Filter(Negate(is.null), z_gene)
    weight_list &lt;- Filter(Negate(is.null), weight_list)
    if (length(z_gene)==0 | length(weight_list)==0) stop(&quot;Please check input data. No twas z-score value available. &quot;)
    
    for (study in names(weight_list)){
        z_snp[[study]] &lt;- harmonize_gwas(gwas_files[study], query_region=paste0(readr::parse_number(&quot;${chrom}&quot;), &quot;:0-&quot;, max_pos+1), ld_variants, c(&quot;beta&quot;, &quot;z&quot;), match_min_prop = 0)
        z_snp[[study]] &lt;- z_snp[[study]][, colnames(z_snp[[study]])[colnames(z_snp[[study]]) %in% c(&quot;chrom&quot;, &quot;pos&quot;, &quot;variant_id&quot;, &quot;A1&quot;, &quot;A2&quot;, &quot;z&quot;, &quot;beta&quot;, &quot;n_sample&quot;,&quot;n_case&quot;, &quot;n_control&quot;, &quot;effect_allele_frequency&quot;)]]
        z_snp[[study]] &lt;- z_snp[[study]][, c(&quot;chrom&quot;, &quot;pos&quot;, colnames(z_snp[[study]])[!colnames(z_snp[[study]]) %in% c(&quot;chrom&quot;, &quot;pos&quot;)])]
    }
    # if weight variants are trimmed, load LD and re-compute twas z score 
    if (${twas_weight_cutoff}!=0 | ${cs_min_cor}!=0 | ${min_pip_cutoff}!=0 | ${max_num_variants}!=Inf ) {
        region_map_list &lt;- split(region_map, names(region_map))
        for (region in names(region_map_list)){
            region_genes &lt;- unique(region_map_list[[region]])
            weight_list_sub &lt;- find_data(weight_list, 2)  
            weight_list_sub &lt;- weight_list_sub[gsub( &quot;\\|.*$&quot;, &quot;&quot;, names(weight_list_sub)) %in% region_genes]
            region_of_interest &lt;- data.frame(chrom = &quot;${chrom}&quot;, start = min(find_data(weight_list_sub, c(2, &quot;p0&quot;))), end =  max(find_data(weight_list_sub, c(2, &quot;p1&quot;))))
            rm(weight_list_sub);gc()
            LD_list &lt;- load_LD_matrix(&quot;${ld_meta_data}&quot;, region_of_interest)
            dup_idx &lt;- which(duplicated(LD_list$combined_LD_variants))
            LD_list &lt;- LD_list[&#39;combined_LD_matrix&#39;]  
            if (length(dup_idx) &gt;= 1) LD_list$combined_LD_matrix &lt;- LD_list$combined_LD_matrix[-dup_idx, -dup_idx]
            for (study in names(weight_list)){
                sub_idx &lt;- which(gsub(&quot;\\|.*$&quot;, &quot;&quot;, names(weight_list[[study]])) %in% region_genes)
                for (context in names(weight_list[[study]][sub_idx])){
                    twas_df &lt;- twas_analysis(weight_list[[study]][[context]]$wgt, z_snp[[study]], LD_list$combined_LD_matrix, rownames(weight_list[[study]][[context]]$wgt))[[1]]
                    z_gene[[study]]$z[z_gene[[study]]$id==context &amp;z_gene[[study]]$gwas_study==study] &lt;- twas_df$z 
                }
            }
            rm(LD_list);gc()     
        }
        rm(LD_list);gc()
    }

    # for each gwas study - merge ctwas input data        
    for (study in names(weight_list)){
      if (is.null(z_gene[[study]])) next
      if (${&quot;TRUE&quot; if multi_group else &quot;FALSE&quot;}) {
          outname &lt;- paste0(name, &quot;.ctwas_region_data.&quot;, study, &quot;.${chrom}&quot;)
      } else {
         contexts &lt;- unique(do.call(c,lapply(z_gene, function(x) unique(x$context))))
         outname &lt;- paste0(name, &quot;.ctwas_region_data.&quot;, study, &quot;.&quot;, contexts, &quot;.${chrom}&quot;)
         names(outname) &lt;- contexts
      }

      colnames(z_snp[[study]])[match(&quot;variant_id&quot;, colnames(z_snp[[study]]))] &lt;-&quot;id&quot; 
      z_snp[[study]] &lt;- z_snp[[study]][, c(&quot;id&quot;, &quot;A1&quot;, &quot;A2&quot;, &quot;z&quot;)]

      # iterate by study-context pair (single group) or by study itself (multigroup) 
      for (group_name in outname){ 
          # assemble regions         
          if (${&quot;TRUE&quot; if multi_group else &quot;FALSE&quot;}) {
              subset_inx &lt;- names(weight_list[[study]])
          } else {
              context &lt;- names(outname)[which(outname==group_name)]
              if (length(weight_list[[study]][grepl(context, names(weight_list[[study]]))])==0) next
              subset_inx &lt;- which(grepl(context, names(weight_list[[study]])))
          }

          res &lt;- assemble_region_data(region_info,
                                    z_snp[[study]],
                                    z_gene[[study]],
                                    weight_list[[study]][subset_inx],
                                    snp_map,
                                    thin = ${thin},
                                    maxSNP = ${maxSNP},
                                    min_group_size = 1,
                                    ncore = ${numThreads})
          region_data &lt;- res$region_data
          boundary_genes &lt;- res$boundary_genes
          region_data_file &lt;- file.path(outputdir, paste0(group_name, &quot;.thin&quot;, ${thin}, &quot;.rds&quot;))
          boundary_gene_file &lt;- gsub(&quot;region_data&quot;,&quot;boundary_genes&quot;, region_data_file)
          saveRDS(region_data, region_data_file, compress=&#39;xz&#39;)
          saveRDS(boundary_genes, boundary_gene_file, compress=&#39;xz&#39;)   
      }
      saveRDS(weight_list[[study]], file.path(outputdir, paste0(name,&quot;.ctwas_weights.&quot;, study, &quot;.${chrom}.rds&quot;)), compress=&#39;xz&#39;)
      saveRDS(list(z_snp=z_snp[[study]], z_gene=z_gene[[study]]), file.path(outputdir,  paste0(name, &quot;.z_gene_snp.&quot;, study, &quot;.${chrom}.rds&quot;)), compress=&#39;xz&#39;)
      weight_list[[study]] &lt;- NULL
      z_gene[[study]] &lt;- NULL
      z_snp[[study]] &lt;- NULL
    }
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-sos notranslate"><div class="highlight"><pre><span></span>[ctwas_2]
## ctwas_2: estimate global group prior using from all regions 
parameter: run_param_est = False
parameter: skip_assembly = False
parameter: thin=1.0
parameter: prior_var_structure = &quot;shared_all&quot;
parameter: multi_group = True
parameter: numThreads = 8
parameter: niter = 50

thin=int(thin) if thin == 1.0 else thin
skip_if(run_param_est == False, &quot; Skip [ctwas_2] parameter estimation. &quot; )
name = f&quot;{name}_{name_suffix}&quot; if name_suffix else name

gwas_study = &#39;c(&#39; + &#39;, &#39;.join(f&#39;&quot;{x}&quot;&#39; for x in gwas_study) + &#39;)&#39;
if multi_group:
    input_pattern = f&quot;{cwd:a}/{step_name.split(&#39;_&#39;)[0]}/{name}.ctwas_region_data.*.chr*.thin{thin}.rds&quot; # by study
else:
    input_pattern = f&quot;{cwd:a}/{step_name.split(&#39;_&#39;)[0]}/{name}.ctwas_region_data.*.*.chr*.thin{thin}.rds&quot; # by study-context pair

input: input_pattern, group_by=&quot;all&quot;
task: trunk_workers = 1, trunk_size = job_size, walltime = walltime, mem = mem, cores = numThreads
R: expand = &#39;${ }&#39;, stdout = f&quot;{cwd:a}/{step_name.split(&#39;_&#39;)[0]}/{name}.ctwas_param_est.{prior_var_structure}.thin{thin}.stdout&quot;, 
stderr = f&quot;{cwd:a}/{step_name.split(&#39;_&#39;)[0]}/{name}.ctwas_param_est.{prior_var_structure}.thin{thin}.stderr&quot;, container = container, entrypoint = entrypoint
    
    library(ctwas)
    library(data.table)
    library(pecotmr)
    outputdir = &quot;${cwd:a}/${step_name.split(&#39;_&#39;)[0]}&quot;
    region_data_files &lt;- c(${_input:r,})
    names(region_data_files) &lt;- gsub(&#39;^.*${name}.ctwas_region_data.\\s*|\\s*.chr*.*$&#39;, &#39;&#39;, region_data_files)   
    gwas_studies &lt;- if (length(${gwas_study})!=0 &amp; ${&quot;TRUE&quot; if multi_group else &quot;FALSE&quot;}) ${gwas_study} else unique(names(region_data_files))

    # assess global parameters
    for (study in gwas_studies){
        region_files &lt;- region_data_files[grepl(paste0(study, &quot;.chr&quot;), region_data_files)]
        region_data &lt;- setNames(lapply(region_files, readRDS), names(region_files))
        contexts &lt;- unique(find_data(region_data, c(4, &quot;context&quot;)))
        # subset either study specific or study-context specific region data based on multigroup/single group
        if (${&quot;TRUE&quot; if multi_group else &quot;FALSE&quot;}) {
            ## subset region data files that are not context-specific but study-specific 
            region_data &lt;- region_data[!sapply(names(region_data), function(x) any(sapply(contexts, function(i) grepl(i, x))))]
            group_name &lt;- &#39;multi&#39;
        } else {
            region_data &lt;- region_data[sapply(names(region_data), function(x) any(sapply(contexts, function(i) grepl(i, x))))]
            group_name &lt;- &#39;single&#39;      
        }
        region_data &lt;- lapply(split(region_data, names(region_data)), function(x) do.call(c, unname(x)))
        saveRDS(region_data, file.path(outputdir, paste0(&quot;${name}.region_data_merged.&quot;, group_name,&quot;.&quot;, study,&quot;.thin${thin}.rds&quot;)), compress=&#39;xz&#39;) #merge and save into one file to be used later
        if (length(region_data[[study]])==0) stop(&quot;Study &quot;, study, &quot; not present in region_data &quot;, file.path(outputdir, paste0(&quot;${name}.region_data_merged.&quot;,  group_name, &quot;.thin${thin}.rds&quot;)))
        group_prior_file &lt;- file.path(outputdir, paste0(&quot;${name}.ctwas_param_${prior_var_structure}.&quot;, study, &quot;.thin${thin}.rds&quot;))
        message(&quot;Start global parameter estimation for &quot;, study, &quot;. &quot;)
        param &lt;- est_param(region_data[[study]],
                  group_prior_var_structure = &quot;${prior_var_structure}&quot;, 
                  niter_prefit = 3,
                  niter = ${niter},
                  min_group_size = 10,
                  ncore = ${numThreads},
                  verbose = TRUE)
        saveRDS(param, group_prior_file, compress=&#39;xz&#39;)
        region_data[[study]] &lt;- NULL
    }
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-sos notranslate"><div class="highlight"><pre><span></span>[ctwas_3]
## ctwas_3: perform finemapping for each region 
parameter: thin=1.0
parameter: maxSNP = 20000
parameter: max_iter = 0
parameter: run_finemapping = False
parameter: prior_var_structure = &quot;shared_all&quot;
# A list of regions to be subset for screening and fine-mapping, for example: &quot;10_80126158_82231647&quot;
parameter: region_name =[]
parameter: numThreads = 4
parameter: multi_group = True
parameter: merge_regions=False
parameter: L=5
import glob

skip_if(run_finemapping == False, &quot; Skip [ctwas_3] fine-mapping. &quot; )
thin=int(thin) if thin == 1.0 else thin
name = f&quot;{name}_{name_suffix}&quot; if name_suffix else name
base = f&quot;{cwd}/{step_name.split(&#39;_&#39;)[0]}/{name}&quot;

region_data_file = (
    [f&quot;{base}.region_data_merged.multi.{study}.thin{thin}.rds&quot; for study in gwas_study]
    if multi_group
    else [x for x in glob.glob(f&quot;{cwd:a}/{step_name.split(&#39;_&#39;)[0]}/{name}.region_data_merged.single.*.thin{thin}.rds&quot;)]
)

region_info_list = []
for region in region_name:
    chrom = region.split(&quot;_&quot;)[0]
    if gwas_study:
        weights = [f&quot;{base}.ctwas_weights.{study}.{chrom}.rds&quot; for study in gwas_study]
        zfiles = [f&quot;{base}.z_gene_snp.{study}.{chrom}.rds&quot; for study in gwas_study]
        params = [x for study in gwas_study for x in glob.glob(f&quot;{base}.ctwas_param_{prior_var_structure}.{study}*.thin{thin}.rds&quot;)]
    else:
        weights = [x for x in glob.glob(f&quot;{base}.ctwas_weights.*.{chrom}.rds&quot;)]
        zfiles = [x for x in glob.glob(f&quot;{base}.z_gene_snp.*.{chrom}.rds&quot;)]
        params = [x for x in glob.glob(f&quot;{base}.ctwas_param_{prior_var_structure}.*.thin{thin}.rds&quot;)]
    region_info_list.append({
        &quot;region_name&quot;: region,
        &quot;weights&quot;: weights,
        &quot;zfiles&quot;: zfiles,
        &quot;params&quot;: params
    })
gwas_study = &#39;c(&#39; + &#39;, &#39;.join(f&#39;&quot;{x}&quot;&#39; for x in gwas_study) + &#39;)&#39;

input: region_info_list[_index][&quot;params&quot;], for_each = &quot;region_info_list&quot;
region_name = region_info_list[_index][&#39;region_name&#39;]
weight_files = region_info_list[_index][&#39;weights&#39;]
z_snp_file  = region_info_list[_index][&#39;zfiles&#39;]
params = region_info_list[_index][&#39;params&#39;]
chrom = region_name.split(&quot;_&quot;)[0]
depends: region_data_file, f&quot;{cwd}/{step_name.split(&#39;_&#39;)[0]}/{name}.snp_map.{chrom}.rds&quot;,f&quot;{cwd}/{step_name.split(&#39;_&#39;)[0]}/{name}.LD_map.rds&quot;
task: trunk_workers = 1, trunk_size = job_size, walltime = walltime, mem = mem, cores = numThreads
R: expand = &#39;${ }&#39;, stdout = f&quot;{cwd:a}/{step_name.split(&#39;_&#39;)[0]}/{name}.ctwas_finemap_res.{prior_var_structure}.{region_name}.thin{thin}.stdout&quot;, 
stderr = f&quot;{cwd:a}/{step_name.split(&#39;_&#39;)[0]}/{name}.ctwas_finemap_res.{prior_var_structure}.{region_name}.thin{thin}.stderr&quot;, container = container, entrypoint = entrypoint

    library(ctwas)
    library(pecotmr)
    library(data.table)
    outputdir = &quot;${cwd:a}/${step_name.split(&#39;_&#39;)[0]}&quot;

    gwas_meta_data &lt;- fread(&quot;${gwas_meta_data}&quot;,data.table=FALSE)
    gwas_studies &lt;- if (length(${gwas_study})!=0) ${gwas_study} else unique(gwas_meta_data$study_id)[,1]

    weight_files &lt;- ${&#39;c(&#39; + &#39;, &#39;.join(f&#39;&quot;{x}&quot;&#39; for x in weight_files) + &#39;)&#39;}
    z_snp_files &lt;- ${&#39;c(&#39; + &#39;, &#39;.join(f&#39;&quot;{x}&quot;&#39; for x in z_snp_file) + &#39;)&#39;}
    param_study_files &lt;- ${&#39;c(&#39; + &#39;, &#39;.join(f&#39;&quot;{x}&quot;&#39; for x in params) + &#39;)&#39;}
    names(param_study_files) &lt;- gsub(&#39;^.*.ctwas_param_${prior_var_structure}.\\s*|\\s*.thin${thin}.*$&#39;, &#39;&#39;, param_study_files)
    param &lt;- setNames(lapply(unname(param_study_files), readRDS), names(param_study_files))
    if (${&quot;TRUE&quot; if multi_group else &quot;FALSE&quot;}){
        param &lt;- param[!sapply(names(param), function(x) any(sapply(paste0(gwas_studies, &quot;.&quot;), function(c) grepl(c, x))))] # gwas_study per each prior 
    } else {
        param &lt;- param[sapply(names(param), function(x) any(sapply(paste0(gwas_studies, &quot;.&quot;), function(c) grepl(c, x))))] # gwas_study x context pair per each prior 
    }

    region_data_files &lt;- ${&#39;c(&#39; + &#39;, &#39;.join(f&#39;&quot;{x}&quot;&#39; for x in region_data_file) + &#39;)&#39;}
    names(weight_files) &lt;- gsub(&#39;^.*.ctwas_weights.\\s*|\\s*.${chrom}.*$&#39;, &#39;&#39;, weight_files) # gwas study names regardless of single/multigroup
    LD_map &lt;- readRDS(&quot;${cwd}/${step_name.split(&#39;_&#39;)[0]}/${name}.LD_map.rds&quot;)
    snp_map &lt;- readRDS(&quot;${cwd}/${step_name.split(&#39;_&#39;)[0]}/${name}.snp_map.${chrom}.rds&quot;)
    names(z_snp_files) &lt;- gsub(&#39;^.*.z_gene_snp.\\s*|\\s*.${chrom}.*$&#39;, &#39;&#39;, z_snp_files)

    ## loop through gwas studies (multigroup) / gwas_study_context groups (single_group)
    for (study in names(param)){
        region_data &lt;- readRDS(region_data_files[grepl(study, region_data_files)])
        finemap_res_file &lt;- file.path(outputdir, paste0(&quot;${name}.ctwas_finemap_res.${prior_var_structure}.${region_name}.&quot;, study, &quot;.thin${thin}.tsv.gz&quot;))
        susie_alpha_file &lt;- gsub(&quot;.tsv.gz&quot;, &quot;.rds&quot;, gsub(&quot;ctwas_finemap_res&quot;, &quot;ctwas_susie_alpha_res&quot;, finemap_res_file))
        if (nrow(region_data[[study]][[gsub(&quot;chr&quot;, &quot;&quot;, &quot;${region_name}&quot;)]]$z_gene)==0) {
            message(&quot;No z_gene data available for &quot;, study, &quot; in ${region_name}. &quot;)
            fwrite(data.frame(), finemap_res_file, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
            next
        }
        
        gwas_study &lt;- study 
        if (${&quot;TRUE&quot; if multi_group else &quot;FALSE&quot;}){
            weights &lt;- readRDS(weight_files[gwas_study])
        } else { # single group 
            context &lt;- gsub( &quot;\\|.*$&quot;, &quot;&quot;, names(param[[study]][[&#39;group_prior&#39;]])[1])
            gwas_study &lt;- gsub(paste0(&quot;.&quot;, context),&quot;&quot;, study)
            weights &lt;- readRDS(weight_files[gwas_study])
            if (length(weights[grepl(context, names(weights))])==0) next # no context specific weight data available 
            weights &lt;- weights[which(grepl(context, names(weights)))] # subset
        }
        group_prior &lt;- param[[study]]$group_prior
        group_prior_var &lt;- param[[study]]$group_prior_var 
        z_snp_list &lt;- readRDS(z_snp_files[gwas_study])
        z_snp &lt;- z_snp_list$z_snp
        z_gene &lt;- z_snp_list$z_gene

        if (${thin} &lt; 1){
            region_data[[study]][gsub(&quot;chr&quot;, &quot;&quot;, &quot;${region_name}&quot;)] &lt;- expand_region_data(region_data[[study]][[gsub(&quot;chr&quot;, &quot;&quot;, &quot;${region_name}&quot;)]],
                                              snp_map,
                                              z_snp,
                                              maxSNP = ${maxSNP},
                                              ncore = ${numThreads})
        }
        screen_res &lt;- screen_regions(region_data[[study]][gsub(&quot;chr&quot;, &quot;&quot;, &quot;${region_name}&quot;)],
                                       group_prior = group_prior, group_prior_var = group_prior_var, min_nonSNP_PIP = 0.5, 
                                       ncore = ${numThreads}, verbose = FALSE, logfile = file.path(outputdir, 
                                       paste0(&quot;${name}.screen_regions.${prior_var_structure}.${region_name}.&quot;, study, &quot;.thin${thin}.log&quot;)))
        screened_region_data &lt;- screen_res$screened_region_data
        # screen_summary &lt;- screen_res$screen_summary
        saveRDS(screen_res, file.path(outputdir, paste0(&quot;${name}.screen_regions.${prior_var_structure}.${region_name}.&quot;, study, &quot;.thin${thin}.rds&quot;)))
        if (length(screened_region_data)==0) {
            message(&quot;No region selected for &quot;, study, &quot; in ${region_name}. &quot;)
            fwrite(data.frame(), finemap_res_file, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
            next
        }
        message(&quot;Screening region completed for &quot;, study, &quot;. &quot;)

        # finemap_regions() argument input 
        args &lt;- list(screened_region_data, LD_map = LD_map, weights = weights, group_prior = group_prior, 
                     group_prior_var = group_prior_var, L = ${L}, ncore = ${numThreads}, save_cor = FALSE, LD_format = &quot;custom&quot;, 
                     LD_loader_fun = ctwas_ld_loader, snpinfo_loader_fun = ctwas_bimfile_loader, verbose = TRUE, logfile = file.path(outputdir, 
                     paste0(&quot;${name}.finemap_res.${prior_var_structure}.${region_name}.&quot;, study, &quot;.thin${thin}.log&quot;)))
        if (as.logical(${max_iter})){
            finemap_res_file &lt;- gsub(study, paste0(study,&quot;_max_iter${max_iter}&quot;),finemap_res_file)
            susie_alpha_file &lt;- gsub(study, paste0(study,&quot;_max_iter${max_iter}&quot;),susie_alpha_file)
            args$max_iter &lt;- ${max_iter}
        }
        # ctwas finemapping 
        res &lt;- do.call(finemap_regions, args)
        finemap_res &lt;- res$finemap_res
        finemap_res$pval &lt;- z2p(finemap_res$z)
        susie_alpha_res &lt;- res$susie_alpha_res
        fwrite(finemap_res, finemap_res_file, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
        saveRDS(susie_alpha_res, susie_alpha_file, compress=&#39;xz&#39;)

        # Get LD diagnosis 
        ld_diag &lt;- diagnose_LD_mismatch_susie(region_ids = gsub(&quot;chr&quot;, &quot;&quot;, &quot;${region_name}&quot;), 
                                  z_snp = z_snp,
                                  LD_map = LD_map, 
                                  gwas_n = nrow(z_snp),
                                  p_diff_thresh = 5e-8,
                                  ncore = ${numThreads},
                                  LD_format = &quot;custom&quot;,
                                  LD_loader_fun = ctwas_ld_loader,
                                  snpinfo_loader_fun = ctwas_bimfile_loader)
        problematic_genes &lt;- get_problematic_genes(ld_diag$problematic_snps, 
                                           weights, 
                                           finemap_res, 
                                           pip_thresh = 0.5)
        # finemapping with no LD for problematic genes 
        problematic_region_ids &lt;- unlist(unique(finemap_res[finemap_res$id %in% problematic_genes, &quot;region_id&quot;]))
        if (length(problematic_region_ids) &gt; 0) {
          message(problematic_region_ids)
          rerun_region_data &lt;- screened_region_data[problematic_region_ids] # using already expanded screened_region_data
          res &lt;- finemap_regions_noLD(rerun_region_data, 
                                      group_prior = group_prior,
                                      group_prior_var = group_prior_var)
          finemap_res &lt;- res$finemap_res
          susie_alpha_res &lt;- res$susie_alpha_res
          message(&quot;Fine-mapping without LD for region ${region_name} with &quot;, study, &quot;. &quot;)
          finemap_res_file &lt;- gsub(study, paste0(study, &quot;_update&quot;), finemap_res_file)
          susie_alpha_file &lt;- gsub(study, paste0(study, &quot;_update&quot;), susie_alpha_file)
          fwrite(finemap_res, finemap_res_file, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
          saveRDS(susie_alpha_res, susie_alpha_file, compress=&#39;xz&#39;)
        }
        saveRDS(ld_diag[1:3], file.path(outputdir, paste0(&quot;${name}.ctwas_ld_diag.${prior_var_structure}.${region_name}.&quot;, study,&quot;.thin${thin}.rds&quot;)))
        pdf(file.path(outputdir, paste0(&quot;${name}.ctwas_ld_diag_plot.${prior_var_structure}.${region_name}.&quot;, study,&quot;.thin${thin}.pdf&quot;)), width = 7, height = 7)
        print(ld_diag$plots)
        dev.off()
        message(&quot;Fine-mapping completed for region ${region_name} with &quot;, study, &quot;. &quot;)
        rm(screened_region_data, ld_diag, susie_alpha_res, res, screen_res)
        gc()

        ## region merging for genes in multiple regions  
        boundary_genes &lt;- file.path(outputdir, paste0(&quot;${name}.ctwas_boundary_genes.&quot;, study, &quot;.${chrom}.thin${thin}.rds&quot;))
        if (file.exists(boundary_genes) &amp; ${&quot;TRUE&quot; if merge_regions else &quot;FALSE&quot;}){
            boundary_genes &lt;- readRDS(boundary_genes)
            high_PIP_finemap_gene_res &lt;- subset(finemap_res, group != &quot;SNP&quot; &amp; susie_pip &gt; 0.5 &amp; !is.na(cs))
            high_PIP_genes &lt;- unique(high_PIP_finemap_gene_res$id)
            selected_boundary_genes &lt;- boundary_genes[boundary_genes$id %in% high_PIP_genes, , drop=FALSE]
            if (nrow(selected_boundary_genes)!=0){
                message(&quot;Fine-mapping for merged region for ${region_name} with &quot;, study, &quot;. &quot;)
                region_info &lt;- get_ctwas_meta_data(&quot;${ld_meta_data}&quot;, names(snp_map))$region_info
                merge_region_res &lt;- merge_region_data(selected_boundary_genes,
                                               region_data[[study]],
                                               region_info = region_info,
                                               LD_map = LD_map,
                                               snp_map = snp_map,
                                               z_snp = z_snp,
                                               z_gene = z_gene,
                                               maxSNP = ${maxSNP})
                finemap_merged_regions_res &lt;- finemap_regions(merge_region_res$merged_region_data,
                                              LD_map = merge_region_res$merged_LD_map,
                                              weights = weights,
                                              group_prior = group_prior,
                                              group_prior_var = group_prior_var,
                                              save_cor = FALSE,
                                              LD_format = &quot;custom&quot;, 
                                              LD_loader_fun = ctwas_ld_loader, 
                                              snpinfo_loader_fun = ctwas_bimfile_loader)
                finemap_res_file &lt;- gsub(study, paste0(study,&quot;_merged&quot;),finemap_res_file)
                susie_alpha_file &lt;- gsub(study, paste0(study, &quot;_merged&quot;), susie_alpha_file)
                finemap_res &lt;- finemap_merged_regions_res$finemap_res
                finemap_res$pval &lt;- z2p(finemap_res$z)
                fwrite(finemap_res, finemap_res_file, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
                saveRDS(finemap_merged_regions_res$susie_alpha_res, susie_alpha_file, compress=&#39;xz&#39;)
            } else {
                message(&quot;No high pip genes found for merged region for fine-mapping. &quot;)
            }
        }
        rm(merge_region_res,boundary_genes,finemap_res, weights, screen_res)
        gc()
    }
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-sos notranslate"><div class="highlight"><pre><span></span>[quantile_twas]
depends: sos_variable(&quot;filtered_regional_xqtl_files&quot;)
parameter: save_ctwas_data = True
parameter: save_mr_result = False
input: filtered_regional_xqtl_files, group_by = lambda x: group_by_region(x, filtered_regional_xqtl_files), group_with = &quot;filtered_region_info&quot;
output_files = [f&#39;{cwd:a}/{step_name}/{name}.{_filtered_region_info[3]}.quantile_twas.tsv.gz&#39;]
if save_ctwas_data:
    output_files.append(f&#39;{cwd:a}/{step_name}/{name}.{_filtered_region_info[3]}.quantile_twas_data.rds&#39;)
if save_mr_result:
    output_files.append(f&#39;{cwd:a}/{step_name}/{name}.{_filtered_region_info[3]}.quantile_mr_result.tsv.gz&#39;)
output: output_files
task: trunk_workers = 1, trunk_size = job_size, walltime = walltime, mem = mem, cores = numThreads, tags = f&#39;{step_name}_{_output[0]:bn}&#39;
R: expand = &#39;${ }&#39;, stdout = f&quot;{_output[0]:n}.stdout&quot;, stderr = f&quot;{_output[0]:n}.stderr&quot;, container = container, entrypoint = entrypoint

    library(dplyr)
    library(data.table)
    library(pecotmr)
    library(readr)
    
    # get xQTL weight information
    xqtl_meta_df &lt;- fread(&quot;${xqtl_meta_data}&quot;) # Get related gene information from the xqtl_meta data table
    xqtl_type_table &lt;- if (isTRUE(file.exists(&quot;${xqtl_type_table}&quot;))) fread(&quot;${xqtl_type_table}&quot;) else NULL
    gwas_studies = c(${paths(regional_data[&quot;GWAS&quot;].keys()):r,})
    gwas_files = c(${paths([v[_filtered_region_info[0]] for k, v in regional_data[&quot;GWAS&quot;].items()]):r,})
    gene_list &lt;- c(${&#39;, &#39;.join([f&quot;&#39;{gene}&#39;&quot; for gene in _filtered_region_info[4]])})

    # Initialize export_twas_weights_db
    export_twas_weights_db &lt;- list()
    export_twas_weights_db[[&quot;${_filtered_region_info[3]}&quot;]] &lt;- list()

    # Initialize twas_weights_results
    twas_weights_results &lt;- list()

    # Create initial weight_db_list
    weight_db_list &lt;- c(${_input:r,})
    names(weight_db_list) &lt;- gene_list

    # Split weight_db_list
    weight_db_list &lt;- split(weight_db_list, names(weight_db_list))

    # Update weight_db_list
    weight_db_list_update &lt;- lapply(weight_db_list, function(file_list) {
        valid_files &lt;- Filter(function(file) {
            if (file.size(file) &gt; 200) {
                content &lt;- tryCatch({
                    data &lt;- readRDS(file)
                }, error = function(e) {
                    warning(paste(&quot;Failed to read RDS file:&quot;, file))
                    NULL
                })

                return(!is.null(content) &amp;&amp; any(sapply(content, function(gene_data) {
                    is.list(gene_data) &amp;&amp; any(sapply(gene_data, function(context_data) {
                        is.list(context_data) &amp;&amp; &quot;twas_variant_names&quot; %in% names(context_data)
                    }))
                })))
            }
            return(FALSE)
        }, file_list)

        if (length(valid_files) == 0) return(NULL)

        return(valid_files)
    })

    weight_db_list_update &lt;- Filter(Negate(is.null), weight_db_list_update)

    if (length(weight_db_list_update) == 0 || all(sapply(weight_db_list_update, length) == 0)) {
        message(&quot;No valid twas weight files found after filtering. Exiting the script.&quot;)
        quit(save = &quot;no&quot;, status = 0) 
    }

    # Check if weight_db_list_update is empty
    # Define tau_values
    tau_values &lt;- seq(0.01, 0.99, 0.01)
    # Main processing loop
    for (gene_db in names(weight_db_list_update)) {
        weight_dbs &lt;- weight_db_list_update[[gene_db]]
        
        twas_weights_results[[gene_db]] &lt;- load_quantile_twas_weights(
            weight_db_files = weight_dbs,
            tau_values = tau_values,
            between_cluster = 0.8,
            num_intervals = 3
        )
        
        if (!is.null(twas_weights_results[[gene_db]]) &amp;&amp; !is.null(twas_weights_results[[gene_db]]$weights)) {
            twas_weights_results[[gene_db]]$data_type &lt;- setNames(
                lapply(names(twas_weights_results[[gene_db]]$weights), function(context) {
                    xqtl_type_table$type[sapply(xqtl_type_table$context, function(x) grepl(x, context))]
                }),
                names(twas_weights_results[[gene_db]]$weights)
            )
        } else {
            print(paste(&quot;Warning: No valid weights found for gene:&quot;, gene_db))
        }
    }

    if (length(twas_weights_results) == 0 || all(sapply(twas_weights_results, is.null))) {
        stop(&quot;twas_weights_results is empty or invalid. Exiting.&quot;)
    }

    saveRDS(twas_weights_results, &quot;${_output[0]:nnn}.grouped_quantile_twas_weight.rds&quot;, compress=&#39;xz&#39;)
    #twas_weights_results
    #Step 2: twas analysis for imputable genes across contexts
    twas_results_db &lt;- twas_pipeline(twas_weights_data = twas_weights_results, 
                                    ld_meta_file_path = &quot;${ld_meta_data}&quot;, 
                                    gwas_meta_file = &quot;${gwas_meta_data}&quot;, 
                                    region_block = &quot;${_filtered_region_info[3]}&quot;, 
                                    quantile_twas = TRUE,  
                                    output_twas_data = ${&quot;TRUE&quot; if save_ctwas_data else &quot;FALSE&quot;} )

    # Merging with xQTL meta-data      
    if (is.null(twas_results_db$twas_result) || nrow(twas_results_db$twas_result) == 0) {
        message(&quot;twas_results_db$twas_result is NULL. Exiting script normally.&quot;)
        quit(save = &quot;no&quot;, status = 0)  
    }

    message(&quot;Merging twas_result with xqtl_meta_df...&quot;)    

    # Check twas_results_db before merging
    common_ids &lt;- intersect(twas_results_db$twas_result$molecular_id, xqtl_meta_df$region_id)       
    if (length(common_ids) &gt; 0) {
        twas_results_db$twas_result &lt;- merge(
            twas_results_db$twas_result,
            xqtl_meta_df[, c(&quot;region_id&quot;, &quot;TSS&quot;, &quot;start&quot;, &quot;end&quot;)],
            by.x = &quot;molecular_id&quot;,
            by.y = &quot;region_id&quot;
        )
        twas_results_db$twas_result &lt;- unique(twas_results_db$twas_result)
    } else {
        warning(&quot;No common molecular_id and region_id. Skipping merge.&quot;)
    }
    
    
    fwrite(twas_results_db$twas_result[, c(2, 1, (ncol(twas_results_db$twas_result)-2):ncol(twas_results_db$twas_result), 3:(ncol(twas_results_db$twas_result)-3))], file = ${_output[0]:r}, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)

    # Step 3: reformat for follow up cTWAS analysis
    if (${&quot;TRUE&quot; if save_ctwas_data else &quot;FALSE&quot;}) {
        saveRDS(twas_results_db$twas_data, &quot;${_output[0]:nnn}.quantile_twas_data.rds&quot;, compress=&#39;xz&#39;)
    }
    if (${&quot;TRUE&quot; if save_mr_result else &quot;FALSE&quot;}) {
        fwrite(twas_results_db$mr_result, file = &quot;${_output[0]:nnn}.quantile_mr_result.tsv.gz&quot;, sep = &quot;\t&quot;, compress = &quot;gzip&quot;)
    }
    message(&quot;quantile twas analysis is completed in this block.&quot;)  
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "sos"
        },
        kernelOptions: {
            name: "sos",
            path: "./code/pecotmr_integration"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'sos'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="SuSiE_enloc.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">xQTL-GWAS pairwise enrichment and colocalization</p>
      </div>
    </a>
    <a class="right-next"
       href="../mnm_analysis/mnm_methods/colocboost.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Multi-trait colocalization using ColocBoost</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-1-twas">Step 1: TWAS</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-2-variant-selection-for-imputable-genes-via-the-best-prediction-methods">Step 2: Variant Selection for Imputable Genes via the Best Prediction Methods</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-3-ctwas-analysis">Step 3: cTWAS analysis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-4-mr-for-candidate-genes">Step 4: MR for candidate genes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-5-quantile-twas-analysis">Step 5: Quantile TWAS analysis</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#input">Input</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gwas-data-input-interface-similar-to-susie-rss">GWAS Data Input Interface (Similar to <code class="docutils literal notranslate"><span class="pre">susie_rss</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#output-of-fine-mapping-twas-pipeline">Output of Fine-Mapping &amp; TWAS Pipeline</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#twas-region-information">TWAS region information</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#output">Output</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iii-run-twas">iii. Run TWAS</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iv-run-ctwas">iv. Run cTWAS</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By The NIH/NIA Alzheimer's Disease Sequencing Project Functional Genomics xQTL Consortium
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2021+, FunGen xQTL Analysis Working Group.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>